
version: 2

# We will verify all of the referential integrity of our TPC-H source
sources:

  - name: SNOWFLAKE_TABLE_STREAM
    schema: "{{target.schema}}"
    database: "{{target.database}}"
    tables:
      - name: customer_cdc_st

  - name: ECONOMIC_ESSENTIALS
    database: |
      {%- if target.name == 'cas2' -%}
        CYBERSYN_FINANCIAL__ECONOMIC_ESSENTIALS
      {%- else -%}
        CYBERSYN_FINANCIAL_ECONOMIC_ESSENTIALS
      {%- endif -%}
    schema: CYBERSYN
    tables:
      - name: FX_RATES_TIMESERIES

  - name: TPC_H
    config:
      tags:
        - "Raw_Layer"
        - "TPC"
    schema: TPCH_SF1
    database: SNOWFLAKE_SAMPLE_DATA
    quoting:
      database: false
      schema: false
      identifier: false

    tables:
      - name: NATION
        columns:
          - name: N_NATIONKEY
            description: "The primary key for this table"
            tests:
              - dbt_constraints.primary_key
          - name: N_REGIONKEY
            tests:
              - not_null
              - dbt_constraints.foreign_key:
                  pk_table_name: source('TPC_H', 'REGION')
                  pk_column_name: R_REGIONKEY

      - name: PART
        columns:
          - name: P_PARTKEY
            description: "The primary key for this table"
            tests:
              - dbt_constraints.primary_key

      - name: PARTSUPP
        columns:
          - name: PS_PARTKEY
            description: "Part of compound primary key for this table"
            tests:
              - not_null
              - dbt_constraints.foreign_key:
                  pk_table_name: source('TPC_H', 'PART')
                  pk_column_name: P_PARTKEY
          - name: PS_SUPPKEY
            description: "Part of compound primary key for this table"
            tests:
              - not_null
              - dbt_constraints.foreign_key:
                  pk_table_name: source('TPC_H', 'SUPPLIER')
                  pk_column_name: S_SUPPKEY
        tests:
          # This is a higher performance way to test compound PK/UK
          - dbt_utils.unique_combination_of_columns:
              combination_of_columns:
                - PS_PARTKEY
                - PS_SUPPKEY
          # How to validate a compound primary key natively
          # - unique:
          #     column_name: "COALESCE(PS_PARTKEY::VARCHAR, '') || '~' || COALESCE(PS_SUPPKEY::VARCHAR, '')"

      - name: REGION
        columns:
          - name: R_REGIONKEY
            description: "The primary key for this table"
            tests:
              - dbt_constraints.primary_key

      - name: SUPPLIER
        columns:
          - name: S_SUPPKEY
            description: "The primary key for this table"
            tests:
              - dbt_constraints.primary_key
          - name: S_NATIONKEY
            tests:
              - not_null
              - dbt_constraints.foreign_key:
                  pk_table_name: source('TPC_H', 'NATION')
                  pk_column_name: N_NATIONKEY

      - name: ORDERS
        columns:
          - name: O_ORDERKEY
            description: "The primary key for this table"
            tests:
              - dbt_constraints.primary_key
          - name: O_CUSTKEY
            tests:
              - not_null
              - dbt_constraints.foreign_key:
                  pk_table_name: source('TPC_H', 'CUSTOMER')
                  pk_column_name: C_CUSTKEY

      - name: CUSTOMER
        columns:
          - name: C_CUSTKEY
            description: "The primary key for dim_customers"
            tests:
              - dbt_constraints.primary_key
          - name: C_NAME
            description: "Customer Name"
            tests:
              - not_null
          - name: C_NATIONKEY
            tests:
              - not_null
              - dbt_constraints.foreign_key:
                  pk_table_name: source('TPC_H', 'NATION')
                  pk_column_name: N_NATIONKEY

      - name: LINEITEM
        columns:
          - name: L_ORDERKEY
            tests:
              - not_null
              - dbt_constraints.foreign_key:
                  pk_table_name: source('TPC_H', 'ORDERS')
                  pk_column_name: O_ORDERKEY
          - name: L_LINENUMBER
            tests:
              - not_null
        tests:
          # This is a higher performance way to test compound PK/UK
          - dbt_utils.unique_combination_of_columns:
              combination_of_columns:
                - L_ORDERKEY
                - L_LINENUMBER
          # How to validate a compound primary key natively
          # - unique:
          #     column_name: "COALESCE(L_ORDERKEY, '') || '~' || L_LINENUMBER, '')"

          # How to validate a compound foreign key
          # Replace relationships with a table-level dbt_constraints.foreign_key test
          - dbt_constraints.foreign_key:
              fk_column_names:
                - L_PARTKEY
                - L_SUPPKEY
              pk_table_name: source('TPC_H', 'PARTSUPP')
              pk_column_names:
                - PS_PARTKEY
                - PS_SUPPKEY
