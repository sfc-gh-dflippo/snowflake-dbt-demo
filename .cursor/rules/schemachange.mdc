---
description: Snowflake SQL script deployment for objects that are not managed by dbt
globs: **/V*.sql, **/R*.sql, **/A*.sql, **/schemachange-config.yml
alwaysApply: false
---

# Schemachange Deployment Guide

**Reference:** [Schemachange GitHub](https://github.com/Snowflake-Labs/schemachange)

Schemachange is a lightweight Python-based tool for managing Snowflake database changes outside of dbt using a migrations-based approach. This guide covers best practices for using schemachange in this project.

---

## Overview

Schemachange applies database changes using SQL script files with specific naming conventions. It tracks change history in a Snowflake table to ensure scripts are applied exactly once (for versioned scripts), whenever new or changed (for repeatable scripts) or every deployment (for always scripts).

**Key Principles:**
- **Versioned scripts** run once and are never re-executed
- **Repeatable scripts** run if new or have a new checksum (must be idempotent)
- **Always scripts** run on every deployment (must be idempotent)
- Scripts execute in alphanumeric order within their category
- Change history is tracked in `<TARGET_DATABASE>.SCHEMACHANGE.CHANGE_HISTORY`

---

## Script Naming Conventions

### Versioned Scripts (V__)

**Format:** `V<major>.<minor>.<patch>__<description>.sql`

**Purpose:** One-time structural changes (tables, schemas, databases)

**Examples:**
```
V1.0.0__initial_setup.sql
V1.1.0__create_base_tables.sql
V1.2.0__add_customer_columns.sql
V2.0.0__restructure_schema.sql
```

**Rules:**
- ✅ Use for: CREATE TABLE, ALTER TABLE, CREATE SCHEMA, CREATE DATABASE
- ✅ Must have semantic version (major.minor.patch)
- ✅ Runs exactly once per database
- ❌ Never modify after deployment
- ❌ Don't use CREATE OR REPLACE (not idempotent)

### Repeatable Scripts (R__)

**Format:** `R__<description>.sql`

**Purpose:** Objects that can be safely recreated or altered

**Examples:**
```
R__Stage_01_utility_functions.sql
R__Stage_01_file_formats.sql
R__Stage_02_create_alter_views.sql
R__Stage_02_create_alter_tables.sql
R__Stage_03_dynamic_tables.sql
R__Stage_04_reporting_views.sql
R__Stage_04_reconciliation_procedure.sql
```

**Rules:**
- ✅ Runs whenever script is new or modified (checksum-based detection)
- ✅ Can be modified freely
- ✅ Use naming conventions to control alphabetical execution order
- ❌ No version numbers in filename

**Supported Objects & Patterns:**

**CREATE OR ALTER (Preferred)** - Maintains data and associations ([Snowflake docs](https://docs.snowflake.com/en/sql-reference/sql/create-or-alter)):
- ✅ **AUTHENTICATION POLICY** - `CREATE OR ALTER AUTHENTICATION POLICY`
- ✅ **DATABASE** - `CREATE OR ALTER DATABASE` (for parameters, not structure)
- ✅ **DATABASE ROLE** - `CREATE OR ALTER DATABASE ROLE`
- ✅ **DYNAMIC TABLE** - `CREATE OR ALTER DYNAMIC TABLE`
- ✅ **FILE FORMAT** - `CREATE OR ALTER FILE FORMAT`
- ✅ **FUNCTION** - `CREATE OR ALTER FUNCTION`
- ✅ **PROCEDURE** - `CREATE OR ALTER PROCEDURE`
- ✅ **ROLE** - `CREATE OR ALTER ROLE`
- ✅ **SCHEMA** - `CREATE OR ALTER SCHEMA` (for parameters, not structure)
- ✅ **STAGE** - `CREATE OR ALTER STAGE`
- ✅ **TABLE** - `CREATE OR ALTER TABLE` (incremental updates)
- ✅ **TASK** - `CREATE OR ALTER TASK` (must be suspended first)
- ✅ **VIEW** - `CREATE OR ALTER VIEW`
- ✅ **WAREHOUSE** - `CREATE OR ALTER WAREHOUSE`

**CREATE OR REPLACE** - Recreates object (drops and creates):
- ✅ **STREAM** - `CREATE OR REPLACE STREAM`
- ✅ **PIPE** - `CREATE OR REPLACE PIPE`
- ✅ **SEQUENCE** - `CREATE OR REPLACE SEQUENCE`

**Key Differences:**
- **CREATE OR ALTER**: Preserves data, tags, policies, and grants (incremental updates)
- **CREATE OR REPLACE**: Drops and recreates (loses all associations)

**Best Practice:** Use `CREATE OR ALTER` when available to preserve object metadata and associations.

### Always Scripts (A__)

**Format:** `A__<description>.sql`

**Purpose:** Scripts that should run on every deployment regardless of changes

**Examples:**
```
A__refresh_permissions.sql
A__update_config_values.sql
```

**Rules:**
- ✅ Runs every time, even if unchanged
- ✅ Use sparingly for admin tasks
- ✅ Use naming conventions to control alphabetical execution order
- ⚠️ Ensure they are truly idempotent

---

## Execution Order

Schemachange executes scripts in this order:

1. **Versioned scripts (V__)**
2. **Repeatable scripts (R__)**
3. **Always scripts (A__)**

**Within each category:** Alphanumeric by filename

**Example execution sequence:**
```
V1.0.0__initial_setup.sql
V1.1.0__create_base_tables.sql
V1.2.0__add_columns.sql
R__Stage_01_create_views.sql
R__Stage_02_reconciliation_procedure.sql
R__Stage_03_utility_functions.sql
A__refresh_permissions.sql
```

---

## Deployment Commands

### Basic Deployment

```bash
# Deploy all pending changes
schemachange deploy \
  --config-folder . \
  --root-folder migrations \
  --connection-name default

# Dry run (preview changes without applying)
schemachange deploy \
  --config-folder . \
  --root-folder migrations \
  --connection-name default \
  --dry-run
```

### Using schemachange-config.yml

Create `schemachange-config.yml` in project root:

```yaml
# schemachange-config.yml
config-version: 1

# The root folder for the database change scripts
root-folder: '/path/to/folder'

# The modules folder for jinja macros and templates to be used across multiple scripts.
modules-folder: null

# Override the default connections.toml file path at snowflake.connector.constants.CONNECTIONS_FILE (OS specific)
connections-file-path: null

# Override the default connections.toml connection name. Other connection-related values will override these connection values.
connection-name: default

# Used to override the default name of the change history table (the default is <TARGET_DATABASE>.SCHEMACHANGE.CHANGE_HISTORY)
change-history-table: null

# Define values for the variables to replaced in change scripts. vars supplied via the command line will be merged into YAML-supplied vars
vars:
  var1: 'value1'
  var2: 'value2'
  secrets:
    var3: 'value3' # This is considered a secret and will not be displayed in any output

# Create the change history schema and table, if they do not exist (the default is False)
create-change-history-table: false

# Enable autocommit feature for DML commands (the default is False)
autocommit: false

# Display verbose debugging details during execution (the default is False)
verbose: false

# Run schemachange in dry run mode (the default is False)
dry-run: false

# A string to include in the QUERY_TAG that is attached to every SQL statement executed
query-tag: 'QUERY_TAG'
```

Then deploy with:
```bash
schemachange deploy --config-folder .
```

### Advanced Options

```bash
# Create change history table automatically
schemachange deploy --create-change-history-table

# Use variables in scripts
schemachange deploy --vars '{"env":"dev","schema":"reconciliation"}'

# Verbose output for debugging
schemachange deploy --verbose

# Custom change history table
schemachange deploy \
  --change-history-table MY_DB.MY_SCHEMA.CHANGE_HISTORY
```

---

## Script Best Practices

### Versioned Scripts (V__)

**DO:**
```sql
-- V1.1.0__create_base_tables.sql
USE SCHEMA DFLIPPO_DB.RECONCILIATION;

CREATE TABLE IF NOT EXISTS SOURCE_CONNECTIONS (
    CONNECTION_ID NUMBER AUTOINCREMENT PRIMARY KEY,
    CONNECTION_NAME VARCHAR(255) NOT NULL UNIQUE,
    CREATED_AT TIMESTAMP_NTZ DEFAULT CURRENT_TIMESTAMP()
);

-- ✅ Use IF NOT EXISTS for safety during debugging
-- ✅ One logical group of tables per script
-- ✅ Include constraints and comments
```

**DON'T:**
```sql
-- ❌ Don't use CREATE OR REPLACE in versioned scripts
CREATE OR REPLACE TABLE SOURCE_CONNECTIONS (...);

-- ❌ Don't mix DDL types (tables + views)
CREATE TABLE ...;
CREATE VIEW ...;  -- Should be in R__ script
```

### Repeatable Scripts (R__)

**DO (Preferred - CREATE OR ALTER):**
```sql
-- R__create_views.sql
USE SCHEMA DFLIPPO_DB.RECONCILIATION;

-- ✅ CREATE OR ALTER preserves tags, policies, and grants
CREATE OR ALTER VIEW VW_TEST_EXECUTION_PLAN AS
SELECT 
    m.MAPPING_ID,
    m.MAPPING_NAME,
    ...
FROM TABLE_MAPPINGS m;

CREATE OR ALTER VIEW VW_RECONCILIATION_SUMMARY AS
SELECT ...;

-- ✅ Group related objects together
-- ✅ Can be modified freely
-- ✅ Maintains object metadata
```

**DO (Alternative - CREATE OR REPLACE):**
```sql
-- R__utility_procedures.sql
USE SCHEMA DFLIPPO_DB.RECONCILIATION;

-- ✅ CREATE OR REPLACE when object associations don't matter
CREATE OR REPLACE PROCEDURE SP_SIMPLE_UTILITY()
RETURNS VARCHAR
LANGUAGE SQL
AS
$$
BEGIN
    RETURN 'Hello';
END;
$$;

-- ✅ Useful for objects without policies/tags
-- ⚠️ Loses all object metadata on each run
```

**DON'T:**
```sql
-- ❌ Don't use CREATE without OR REPLACE/OR ALTER
CREATE VIEW VW_TEST_PLAN AS ...;

-- ❌ Don't create/alter tables in repeatable scripts (use versioned)
CREATE OR ALTER TABLE CONFIG (...);  -- Use V__ script instead

-- ❌ Don't use CREATE OR REPLACE when CREATE OR ALTER is available
CREATE OR REPLACE VIEW VW_TAGGED_VIEW AS ...;  -- Use CREATE OR ALTER instead
```

---

## Project Integration

### Directory Structure

```
project/
├── migrations/
│   ├── V1.1.0__create_base_tables.sql
│   ├── R__Stage_01_create_views.sql
│   ├── R__Stage_02_reconciliation_procedure.sql
│   └── R__Stage_03_utility_functions.sql
├── schemachange-config.yml
└── .env
```

### Configuration File

**schemachange-config.yml:**
```yaml
root-folder: migrations
change-history-table: <TARGET_DATABASE>.SCHEMACHANGE.CHANGE_HISTORY
create-change-history-table: true
snowflake-connection-name: default
```

### Snowflake Connections

Use Snowflake connection profiles (`~/.snowflake/connections.toml`).

---

## Snowflake CLI Integration

Schemachange works alongside `snow` CLI:

```bash
# Use snow for ad-hoc queries
snow sql -q "SELECT CURRENT_DATABASE()" -c default

# Use schemachange for structured deployments
schemachange deploy --config-folder .

# Combine for workflow automation
snow sql -f setup_database.sql -c default
schemachange deploy --config-folder .
snow sql -f verify_deployment.sql -c default
```

---

## Common Workflows

### Initial Project Setup

```bash
# 1. Create change history database/schema manually
snow sql -c default <<EOF
CREATE DATABASE IF NOT EXISTS METADATA;
CREATE SCHEMA IF NOT EXISTS <TARGET_DATABASE>.SCHEMACHANGE;
EOF

# 2. Run schemachange with auto-create
schemachange deploy \
  --config-folder . \
  --create-change-history-table

# 3. Verify deployment
snow sql -c default -q "
SELECT * FROM <TARGET_DATABASE>.SCHEMACHANGE.CHANGE_HISTORY 
ORDER BY INSTALLED_ON DESC LIMIT 100
"
```

---

## Troubleshooting

### Change History Table

**View applied changes:**
```sql
SELECT 
    VERSION,
    DESCRIPTION,
    SCRIPT
    SCRIPT_TYPE,
    CHECKSUM,
    EXECUTION_TIME,
    STATUS,
    INSTALLED_BY,
    INSTALLED_ON
FROM <TARGET_DATABASE>.SCHEMACHANGE.CHANGE_HISTORY
ORDER BY INSTALLED_ON;
```

### Failed Deployment

**Check last failed script:**
```sql
SELECT * FROM <TARGET_DATABASE>.SCHEMACHANGE.CHANGE_HISTORY
WHERE STATUS != 'Success'
ORDER BY INSTALLED_ON DESC
LIMIT 1;
```

### Reverting Changes

**Schemachange does NOT support rollback.** To revert:

1. Update a repeatable script and redeploy
2. Or create a new versioned script with reverse changes
3. Or manually undo changes via SQL

---

## CI/CD Integration

### GitHub Actions Example

```yaml
# .github/workflows/prod-deploy.yml
name: Deploy Database Changes

on:
  push:
    branches: [main]
    paths:
      - 'migrations/**'

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Install schemachange
        run: pip install schemachange
      
      - name: Deploy to Snowflake
        env:
          SNOWFLAKE_CONNECTION_NAME: $${{ env.SNOWFLAKE_CONNECTION_NAME }}
          SOURCE_DATABASE: ${{ env.SOURCE_DATABASE }}
          SOURCE_SCHEMA: ${{ env.SOURCE_SCHEMA }}
          TARGET_DATABASE: ${{ env.TARGET_DATABASE }}
          TARGET_SCHEMA: ${{ env.TARGET_SCHEMA }}
          SNOWFLAKE_SCHEMA: ${{ secrets.SNOWFLAKE_USER }}
          SNOWFLAKE_PASSWORD: ${{ secrets.SNOWFLAKE_PASSWORD }}
        run: |
          schemachange deploy \
            --config-folder . \
            --verbose
```

```yaml
# schemachange-config.yml
config-version: 1

connection-name: "{{ env_var('SNOWFLAKE_CONNECTION_NAME') }}"
change-history-table: "{{ env_var('TARGET_DATABASE') }}.SCHEMACHANGE.CHANGE_HISTORY"
create-change-history-table: true

vars:
  tgt_database_name: "{{ env_var('TARGET_DATABASE') }}"
  tgt_schema_name: "{{ env_var('TARGET_SCHEMA') }}"
  src_database_name: "{{ env_var('SOURCE_DATABASE') }}"
  src_schema_name: "{{ env_var('SOURCE_SCHEMA') }}"
```

```sql
# create_alter_views.sql
-- R__create_views.sql
USE SCHEMA {{ tgt_database_name }}.{{ tgt_schema_name }};

CREATE OR ALTER VIEW VW_TEST_EXECUTION_PLAN AS
SELECT 
    m.MAPPING_ID,
    m.MAPPING_NAME,
    ...
FROM {{ src_database_name }}.{{ src_schema_name }}.TABLE_MAPPINGS m;
```

---

## Best Practices Summary

### ✅ DO

- Use repeatable scripts (R__) for objects that support it
- Use versioned scripts (V__) for one-time structural changes
- Use naming conventions to control the execution order for repeatable and always scripts
- **Prefer `CREATE OR ALTER`** in repeatable scripts (preserves metadata)
- Use `CREATE OR REPLACE` only when `CREATE OR ALTER` is not available
- Use `CREATE TABLE IF NOT EXISTS` in versioned scripts for safety
- Test with `--dry-run` before production deployments
- Keep scripts small and focused (one logical change per script)
- Use descriptive filenames
- Review change history regularly
- Reference [Snowflake CREATE OR ALTER docs](https://docs.snowflake.com/en/sql-reference/sql/create-or-alter) for supported objects

### ❌ DON'T

- Don't modify versioned scripts after deployment
- Don't use version numbers in repeatable script names
- Don't use `CREATE OR REPLACE` when `CREATE OR ALTER` is available (loses metadata)
- Don't mix DDL types inappropriately (tables in the same script as views)
- Don't rely on manual rollbacks
- Don't skip testing in dev/staging environments
- Don't commit credentials to version control

---

## Quick Reference

```bash
# Common commands
schemachange deploy --config-folder .                    # Deploy all changes
schemachange deploy --config-folder . --dry-run          # Preview changes
schemachange deploy --config-folder . --verbose          # Debug output
schemachange render migrations/R__Stage_01_views.sql              # Test Jinja templates

# File naming
V1.0.0__description.sql    # Versioned (one-time)
R__Stage_01_description.sql         # Repeatable (when new or modified)
A__Stage_01_description.sql         # Always (every deployment, even if unchanged)

# Execution order
V__ (versioned) → R__ (repeatable) → A__ (always)

# Idempotent patterns
CREATE OR ALTER VIEW ...        # Preferred - preserves metadata
CREATE OR ALTER PROCEDURE ...   # Preferred - preserves metadata
CREATE OR REPLACE STREAM ...    # When CREATE OR ALTER not available
```

---

**For full documentation:** https://github.com/Snowflake-Labs/schemachange
