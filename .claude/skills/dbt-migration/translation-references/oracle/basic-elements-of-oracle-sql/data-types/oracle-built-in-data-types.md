---
description:
  Beginning with Oracle Database 12_c_, you can specify a maximum size of 32767 bytes for the
  VARCHAR2, NVARCHAR2, and RAW data types. You can control whether your database supports this new
  maximum siz
source_url: https://docs.snowflake.com/en/migrations/snowconvert-docs/translation-references/oracle/basic-elements-of-oracle-sql/data-types/oracle-built-in-data-types
title: SnowConvert AI - Oracle - Oracle Built-in Data Types | Snowflake Documentation
---

## Extended Data Types[¶](#extended-data-types)

### Description[¶](#description)

> Beginning with Oracle Database 12_c\_, you can specify a maximum size of 32767 bytes for the
> `VARCHAR2`, `NVARCHAR2`, and `RAW` data types. You can control whether your database supports this
> new maximum size by setting the initialization parameter `MAX_STRING_SIZE`.
>
> A `VARCHAR2` or `NVARCHAR2` data type with a declared size of greater than 4000 bytes, or a `RAW`
> data type with a declared size of greater than 2000 bytes, is an **extended** **data** **type**.
> ([Oracle SQL Language Reference Extended Data Type](https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/Data-Types.html#GUID-8EFA29E9-E8D8-40A6-A43E-954908C954A4)).

Oracle allows increasing the database max string size from `STANDARD` to `EXTENDED`, however,
Snowflake **does not contain an equivalent** for this functionality.

Therefore `VARCHAR2`, `NVARCHAR2` and `RAW` extended Data Types are not supported in Snowflake, and
they are transformed just as regular `VARCHAR2`, `NVARCHAR2`, and `RAW` data types. Check
[Character Data Types](#character-data-types) and [RAW Data Types](#raw-and-long-raw-data-types) for
more information.

### Known Issues[¶](#known-issues)

#### 1. MAX STRING SIZE not recognized[¶](#max-string-size-not-recognized)

`ALTER SYSTEM SET MAX_STRING_SIZE='EXTENDED';`

Is not being parsed by SnowConvert.

### Related EWIs[¶](#related-ewis)

No related EWIs.

## JSON Data Type[¶](#json-data-type)

### Description[¶](#id1)

> Oracle Database supports JSON natively with relational database features, including transactions,
> indexing, declarative querying, and views. Unlike relational data, JSON data can be stored in the
> database, indexed, and queried without any need for a schema that defines the data.
> ([Oracle SQL Language Reference JSON Data Type](https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/Data-Types.html#GUID-E441F541-BA31-4E8C-B7B4-D2FB8C42D0DF)).

The JSON data types are transformed to VARIANT in order to emulate the Oracle behavior.

```
JSON
```

### Sample Source Patterns[¶](#sample-source-patterns)

#### JSON Data Type as a column in Create Table[¶](#json-data-type-as-a-column-in-create-table)

##### Oracle[¶](#oracle)

```
CREATE TABLE jsontable (
	json_column JSON
);

INSERT INTO jsontable VALUES('{"id": 1, "content":"json content"}');
INSERT INTO jsontable VALUES('{"stringdata": "this is a text","number": 1,"numberNeg": -1,"booleanT": true,"booleanGF": false,"nullvalue": null,"object": {"1": 1,"2": 2},"array": [1, 2, 3]}');
INSERT INTO jsontable VALUES(JSON('{"id": 4}'));

SELECT  * FROM jsontable;
```

##### Result[¶](#result)

<!-- prettier-ignore -->
|COL1|
|---|
|{“id”:1,”content”:”json content”}|
|{“stringdata”:”this is a text”,”number”:1,”numberNeg”:-1,”booleanT”:true,”booleanGF”:false,”nullvalue”:null,”object”:{“1”:1,”2”:2},”array”:[1,2,3]}|
|{“id”:4}|

##### Snowflake[¶](#snowflake)

```
CREATE OR REPLACE TABLE jsontable (
	json_column VARIANT
)
COMMENT = '{"origin":"sf_sc","name":"snowconvert","version":{"major":1, "minor":0},{"attributes":{"component":"oracle"}}'
;

INSERT INTO jsontable
VALUES('{"id": 1, "content":"json content"}');

INSERT INTO jsontable
VALUES('{"stringdata": "this is a text","number": 1,"numberNeg": -1,"booleanT": true,"booleanGF": false,"nullvalue": null,"object": {"1": 1,"2": 2},"array": [1, 2, 3]}');

INSERT INTO jsontable
VALUES(JSON('{"id": 4}') !!!RESOLVE EWI!!! /*** SSC-EWI-0073 - PENDING FUNCTIONAL EQUIVALENCE REVIEW FOR 'JSON' NODE ***/!!!);

SELECT  * FROM
	jsontable;
```

Warning

JSON data insertions are not being correctly handled. Check the [Recommendations](#json-data-type)
section for workarounds.

### Known Issues[¶](#id2)

**1. JSON data insertions**

JSON data insertions are not being correctly handled by SnowConvert.

**2. JSON objects manipulation**

The usages of JSON objects (columns, variables, or parameters) are not correctly converted by
SnowConvert AI. Check the [Recommendations](#json-data-type) section for workarounds

### Recommendations[¶](#recommendations)

#### 1. JSON **Data Type** translation workaround[¶](#json-data-type-translation-workaround)

JSON datatype is translated to _VARIANT_, so the information can be formatted using the Snowflake
_PARSE_JSON_ function. This approach will allow you to store, query, and operate the JSON data in
Snowflake using similar syntax as Oracle.

##### Oracle[¶](#id3)

```
CREATE TABLE jsontable (
	json_column JSON
);

INSERT INTO jsontable VALUES('{"id": 1, "content":"json content"}');
INSERT INTO jsontable VALUES('{"id": 2, "content": {"header": "header text one", "content": "content text one"}}');
INSERT INTO jsontable VALUES('{"id": 3, "content": {"header": "header tex two", "content": "content text two"}}');

SELECT * FROM jsontable;
SELECT 'ID: ' || jt.json_column.id, 'HEADER: ' || UPPER(jt.json_column.content.header) FROM jsontable jt;
```

##### Result 1[¶](#result-1)

<!-- prettier-ignore -->
|JSON_SERIALIZE(JSON_COLUMN)|
|---|
|{“id”:1,”content”:”json content”}|
|{“id”:2,”content”:{“header”:”header text one”,”content”:”content text one”}}|
|{“id”:3,”content”:{“header”:”header tex two”,”content”:”content text two”}}|

##### Result 2[¶](#result-2)

<!-- prettier-ignore -->
|‘ID:’ JT.JSON_COLUMN.ID|‘HEADER:’ UPPER(JT.JSON_COLUMN.CONTENT.HEADER)|
|---|---|
|ID: 1|HEADER:|
|ID: 2|HEADER: “HEADER TEXT ONE”|
|ID: 3|HEADER: “HEADER TEX TWO”|

##### Snowflake[¶](#id4)

```
CREATE OR REPLACE TABLE jsontable (
	json_column VARIANT
)
COMMENT = '{"origin":"sf_sc","name":"snowconvert","version":{"major":1, "minor":0},{"attributes":{"component":"oracle"}}'
;

INSERT INTO jsontable
VALUES('{"id": 1, "content":"json content"}');

INSERT INTO jsontable
VALUES('{"id": 2, "content": {"header": "header text one", "content": "content text one"}}');

INSERT INTO jsontable
VALUES('{"id": 3, "content": {"header": "header tex two", "content": "content text two"}}');

SELECT * FROM
	jsontable;

SELECT 'ID: ' || NVL(jt.json_column.id :: STRING, ''), 'HEADER: ' || NVL(UPPER(jt.json_column.content.header) :: STRING, '') FROM
	jsontable jt;
```

##### Result 1[¶](#id5)

<!-- prettier-ignore -->
|JSON_COLUMN|
|---|
|{ “content”: “json content”, “id”: 1}|
|{ “content”: { “content”: “content text one”, “header”: “header text one” }, “id”: 2}|
|{ “content”: { “content”: “content text two”, “header”: “header tex two” }, “id”: 3}|

##### Result 2[¶](#id6)

<!-- prettier-ignore -->
|‘ID: ‘ JT.JSON_COLUMN:ID|‘HEADER: ‘ UPPER(JT.JSON_COLUMN:CONTENT:HEADER)|
|---|---|
|ID: 1||
|ID: 2|HEADER: HEADER TEXT ONE|
|ID: 3|HEADER: HEADER TEX TWO|

**Note:**

You must use _SELECT_ as the INSERT _INTO_ argument instead of the _VALUES_ clause to use the
_PARSE_JSON_ function.

**Note:**

Use the ‘:’ instead of the ‘.’ operator to access the JSON object properties. It allows several
levels of nesting in both engines.

### Related EWIs[¶](#id7)

1. [SSC-EWI-0073](../../../../general/technical-documentation/issues-and-troubleshooting/conversion-issues/generalEWI.html#ssc-ewi-0073):
   Pending Functional Equivalence Review

## LONG Data Type[¶](#long-data-type)

> `LONG` columns store variable-length character strings containing up to 2 gigabytes -1, or 231-1
> bytes. `LONG` columns have many of the characteristics of `VARCHAR2` columns. You can use `LONG`
> columns to store long text strings. The length of `LONG` values may be limited by the memory
> available on your computer.
> ([Oracle SQL Language Reference Long Data Type](https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/Data-Types.html#GUID-F6309DF8-162F-48A4-9454-FEE59EC6644F))

```
LONG
```

### Sample Source Patterns[¶](#id8)

#### Long in Create Table[¶](#long-in-create-table)

##### Oracle[¶](#id9)

```
CREATE TABLE long_table
(
     id 	  NUMBER,
     long_column  LONG
);

 INSERT INTO long_table VALUES (1, 'this is a text');
```

##### Snowflake[¶](#id10)

```
CREATE OR REPLACE TABLE long_table
 (
      id NUMBER(38, 18) /*** SSC-FDM-0006 - NUMBER TYPE COLUMN MAY NOT BEHAVE SIMILARLY IN SNOWFLAKE. ***/,
      long_column VARCHAR
 )
 COMMENT = '{"origin":"sf_sc","name":"snowconvert","version":{"major":1, "minor":0},{"attributes":{"component":"oracle"}}'
 ;

 INSERT INTO long_table
 VALUES (1, 'this is a text');
```

#### Retrieving data from a Long column[¶](#retrieving-data-from-a-long-column)

##### Oracle[¶](#id11)

```
SELECT long_column FROM long_table;
```

##### Result[¶](#id12)

<!-- prettier-ignore -->
|LONG_COLUMN|
|---|
|this is a text|

##### Snowflake[¶](#id13)

```
SELECT long_column FROM
long_table;
```

##### Result[¶](#id14)

<!-- prettier-ignore -->
|LONG_COLUMN|
|---|
|this is a text|

### Known Issues[¶](#id15)

#### 1. The max length of long (Oracle) and varchar (Snowflake) are different[¶](#the-max-length-of-long-oracle-and-varchar-snowflake-are-different)

According to
[Oracle documentation](https://docs.oracle.com/en/database/oracle/oracle-database/21/lnoci/data-types.html#GUID-A4B5A998-038A-44BA-A673-C41BEAC05C42),
Long column can store up to 2 gigabytes of data, but
[Snowflake varchar](https://docs.snowflake.com/en/sql-reference/data-types-text.html#varchar) is
limited to 16Mb.

##### 2. Cast of Long column[¶](#cast-of-long-column)

Long data type only can be cast to CLOB data type, and the only way to achieve this is using the
[TO_LOB function](https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/TO_LOB.html#GUID-35810313-029E-4CB8-8C27-DF432FA3C253),
this function only works if is used in the select list of a subquery in an INSERT statement.
Consider the following sample

##### Oracle[¶](#id16)

```
CREATE TABLE target_table (col CLOB);

INSERT INTO target_table (SELECT TO_LOB(long_column) FROM long_table);
```

Warning

If the target table column data type is different from CLOB, Oracle may insert null values or
display an error when attempting to insert the data.

### Related EWIs[¶](#id17)

1. [SSC-FDM-0006](../../../../general/technical-documentation/issues-and-troubleshooting/functional-difference/generalFDM.html#ssc-fdm-0006):
   Number type column may not behave similarly in Snowflake

## RAW and LONG RAW Data types[¶](#raw-and-long-raw-data-types)

### Description[¶](#id18)

> The `RAW` and `LONG` `RAW` data types store data that is not to be explicitly converted by Oracle
> Database when moving data between different systems. These data types are intended for binary data
> or byte strings.
> ([Oracle SQL Language Reference Row and Long Raw Data Types](https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/Data-Types.html#GUID-4FD497DD-3331-4C25-9147-3CEBEFDBFF22))

```
{ LONG RAW | RAW (size) }
```

### Sample Source Patterns[¶](#id19)

#### Raw and Long Raw in Create Table[¶](#raw-and-long-raw-in-create-table)

##### Oracle[¶](#id20)

```
CREATE TABLE raw_table
(
     id INTEGER,
     raw_column RAW(2000),
     long_raw_column LONG RAW
);

INSERT  INTO raw_table values(1, 'FF00FF00FF', 'FF00FF00FFAABAABABABABA917843210984237123ABABABABAABBAAABBACDFFD');
INSERT  INTO raw_table values(2, 'AAAAAAAAAA', 'ABABABABABABABABABABABABABABABAbABAbABAABABAAABABABABABABABABABABA');
--Insert with largest string posible (2000 HEX characters)
INSERT INTO raw_table VALUES (3, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA1AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA', 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA1AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA')
```

##### Snowflake CREATE OR REPLACE TABLE raw_table[¶](#snowflake-create-or-replace-table-raw-table)

```
CREATE OR REPLACE TABLE raw_table
     (
          id INTEGER,
          raw_column BINARY,
          long_raw_column BINARY
     )
     COMMENT = '{"origin":"sf_sc","name":"snowconvert","version":{"major":1, "minor":0},{"attributes":{"component":"oracle"}}'
     ;

     INSERT  INTO raw_table
     values(1, 'FF00FF00FF', 'FF00FF00FFAABAABABABABA917843210984237123ABABABABAABBAAABBACDFFD');

     INSERT  INTO raw_table
     values(2, 'AAAAAAAAAA', 'ABABABABABABABABABABABABABABABAbABAbABAABABAAABABABABABABABABABABA');

     --Insert with largest string posible (2000 HEX characters)
INSERT INTO raw_table
     VALUES (3, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA1AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA', 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA1AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA');
```

#### Retrieving data from Raw and Long Raw column[¶](#retrieving-data-from-raw-and-long-raw-column)

##### Oracle[¶](#id21)

```
SELECT * FROM raw_table ORDER BY id;
```

##### Result[¶](#id22)

<!-- prettier-ignore -->
|ID|RAW_COLUMN|LONG_RAW_COLUMN|
|---|---|---|
|1||ªº««««© 2 B7 :ºººº«ºª»¬ßý|
|2|ªªªªª|«««««««««««««««««««ªººªºººººººººº|
|3|ªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªª|ªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªª|

##### Snowflake[¶](#id23)

```
SELECT * FROM
raw_table
ORDER BY id;
```

##### Result[¶](#id24)

<!-- prettier-ignore -->
|ID|RAW_COLUMN|LONG_RAW_COLUMN|
|---|---|---|
|1||ªº««««© 2 B7 :ºººº«ºª»¬ßý|
|2|ªªªªª|«««««««««««««««««««ªººªºººººººººº|
|3|ªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªª|ªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªª|

### Known Issues[¶](#id25)

No issues were found.

### Related EWIs[¶](#id26)

No related EWIs.

## Numeric Data Types[¶](#numeric-data-types)

### Description[¶](#id27)

> The Oracle Database numeric data types store positive and negative fixed and floating-point
> numbers, zero, infinity, and values that are the undefined result of an operation—“not a number”
> or `NAN`.
> ([Oracle Language Reference Numeric Data Types](https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/Data-Types.html#GUID-9401BC04-81C4-4CD5-99E7-C5E25C83F608))

#### Notes on arithmetic operations[¶](#notes-on-arithmetic-operations)

Please be aware that every operation performed on numerical datatypes is internally stored as a
Number. Furthermore, depending on the operation performed it is possible to incur an error related
to how intermediate values are stored within Snowflake, for more information on
[Snowflake’s post on intermediate numbers in Snowflake](https://community.snowflake.com/s/question/0D50Z00008HhSHCSA3/sql-compilation-error-invalid-intermediate-datatype-number7148).

## FLOAT Data Type[¶](#float-data-type)

### Description[¶](#id28)

> The `FLOAT` data type is a subtype of `NUMBER`. It can be specified with or without precision,
> which has the same definition it has for`NUMBER`and can range from 1 to 126. Scale cannot be
> specified but is interpreted from the data.
> ([Oracle Language Reference Float Data Type](https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/Data-Types.html#GUID-10D4D073-866D-4BD4-B3E9-ED153D505A6A))

Warning

#### Notes on arithmetic operations

Please be aware that every operation performed on numerical datatypes is internally stored as a
Number. Furthermore, depending on the operation performed it is possible to incur an error related
to how intermediate values are stored within Snowflake, for more information please check this post
on
[Snowflake’s post on intermediate numbers in Snowflake](https://community.snowflake.com/s/question/0D50Z00008HhSHCSA3/sql-compilation-error-invalid-intermediate-datatype-number7148).

### Sample Source Patterns[¶](#id30)

Please, consider the following table and its inserts for the examples below:

#### Float data type in Create Table[¶](#float-data-type-in-create-table)

##### Oracle[¶](#id31)

```
CREATE TABLE float_data_type_table(
col1 FLOAT,
col2 FLOAT(5),
col3 FLOAT(126)
);

INSERT INTO float_data_type_table (col1) VALUES (100.55555);
INSERT INTO float_data_type_table (col1) VALUES (1.9);
INSERT INTO float_data_type_table (col2) VALUES (1.23);
INSERT INTO float_data_type_table (col2) VALUES (7.89);
INSERT INTO float_data_type_table (col2) VALUES (12.79);
INSERT INTO float_data_type_table (col2) VALUES (123.45);
INSERT INTO float_data_type_table (col3) VALUES (1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111.99999999999999999999555555);
```

##### Snowflake[¶](#id32)

```
CREATE OR REPLACE TABLE float_data_type_table (
col1 FLOAT,
col2 FLOAT(5),
col3 FLOAT(126)
)
COMMENT = '{"origin":"sf_sc","name":"snowconvert","version":{"major":1, "minor":0},{"attributes":{"component":"oracle"}}'
;

INSERT INTO float_data_type_table(col1) VALUES (100.55555);

INSERT INTO float_data_type_table(col1) VALUES (1.9);

INSERT INTO float_data_type_table(col2) VALUES (1.23);

INSERT INTO float_data_type_table(col2) VALUES (7.89);

INSERT INTO float_data_type_table(col2) VALUES (12.79);

INSERT INTO float_data_type_table(col2) VALUES (123.45);

INSERT INTO float_data_type_table(col3) VALUES (1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111.99999999999999999999555555);
```

#### FLOAT[¶](#float)

There are no differences between Oracle and Snowflake regarding FLOAT data type without precision.

##### Oracle[¶](#id33)

```
SELECT col1 FROM float_data_type_table;
```

##### Result[¶](#id34)

<!-- prettier-ignore -->
|col1|
|---|
|100.55555|
|1.9|

##### Snowflake[¶](#id35)

```
SELECT col1 FROM
float_data_type_table;
```

##### Result[¶](#id36)

<!-- prettier-ignore -->
|col1|
|---|
|100.55555|
|1.9|

#### FLOAT ( p )[¶](#float-p)

Queries results may not be equivalent when the precision **(p)** is specified in the`FLOAT`data
type. There are small rounding differences.

##### Oracle[¶](#id37)

```
SELECT col2 FROM float_data_type_table;

SELECT col3 FROM float_data_type_table;
```

##### Result[¶](#id38)

<!-- prettier-ignore -->
|col2|
|---|
|1.2|
|7.9|
|13|
|120|
|                                                                                                      |
|col3|
|—————————————————————————————————-|
|1111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000|
|                                                                                                      |

##### Snowflake[¶](#id39)

```
SELECT col2 FROM
float_data_type_table;

SELECT col3 FROM
float_data_type_table;
```

##### Result[¶](#id40)

<!-- prettier-ignore -->
|col2|
|---|
|1.23|
|7.89|
|12.79|
|123.45|
|                                                                                                      |
|col3|
|—————————————————————————————————-|
|1111111111111111000000000000000000000000000000000000000000000000000000000000000000000000000000000000|

### Known Issues[¶](#id41)

#### 1. FLOAT data type with precision[¶](#float-data-type-with-precision)

When the **FLOAT** data type has precision, the queries results may have small rounding differences.

### Related EWIs[¶](#id42)

No related EWIs.

## NUMBER Data Type[¶](#number-data-type)

### Description[¶](#id43)

> The `NUMBER` data type stores zero as well as positive and negative fixed numbers with absolute
> values from 1.0 x 10-130 to but not including 1.0 x 10126. If you specify an arithmetic expression
> whose value has an absolute value greater than or equal to 1.0 x 10126, then Oracle returns an
> error. Each `NUMBER` value requires from 1 to 22 bytes.
> ([Oracle Language Reference Number Data Type](https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/Data-Types.html#GUID-75209AF6-476D-4C44-A5DC-5FA70D701B78)).

The `NUMBER` data type can be specified using the following form `NUMBER(p, s)` (both parameters are
optional) where:

- `p` is the **precision** or the maximum number of significant decimal digits, where the most
  significant digit is the left-most nonzero digit, and the least significant digit is the
  right-most known digit. The precision can range from 0 to 38.
- `s` is the **scale** or the number of digits from the decimal point to the least significant
  digit. The scale can range from -84 to 127.

On Oracle, not specifying precision (using `NUMBER or NUMBER(*)`) causes the column to be created as
an “undefined precision”. This means that Oracle will store values dynamically, allowing to store
any number within that column. Snowflake does not support this functionality; for this reason, they
will be changed to NUMBER(38, 18), allowing to store the widest variety of numbers.

Warning

#### Notes on arithmetic operations

Please be aware that every operation performed on numerical data types is internally stored as a
Number. Furthermore, depending on the operation performed it is possible to incur an error related
to how intermediate values are stored within Snowflake, for more information please check this post
on
[Snowflake’s post on intermediate numbers in Snowflake](https://community.snowflake.com/s/question/0D50Z00008HhSHCSA3/sql-compilation-error-invalid-intermediate-datatype-number7148)
or check the functional equivalence message
[SSC-FDM-0006](../../../../general/technical-documentation/issues-and-troubleshooting/functional-difference/generalFDM.html#ssc-fdm-0006).

### Sample Source Patterns[¶](#id45)

Please, consider the following table and its inserts for the examples below:

#### Number data types in Create Table[¶](#number-data-types-in-create-table)

##### Oracle[¶](#id46)

```
CREATE TABLE number_data_type_table
(
col1 NUMBER,
col2 NUMBER(1),
col3 NUMBER(10, 5),
col4 NUMBER(5, -2),
col5 NUMBER(4, 5)
);

INSERT INTO number_data_type_table(COL1) VALUES(100);
INSERT INTO number_data_type_table(COL2) VALUES(1.99999);
INSERT INTO number_data_type_table(COL3) VALUES(12345.12345);
INSERT INTO number_data_type_table(COL4) VALUES(16430.55555);
INSERT INTO number_data_type_table (COL4) VALUES(17550.55555);
INSERT INTO number_data_type_table(COL5) VALUES(0.00009);
INSERT INTO number_data_type_table(COL5) VALUES(0.000021);
INSERT INTO number_data_type_table(COL5) VALUES(0.012678912);
```

##### Snowflake[¶](#id47)

```
CREATE OR REPLACE TABLE number_data_type_table
(
col1 NUMBER(38, 18) /*** SSC-FDM-0006 - NUMBER TYPE COLUMN MAY NOT BEHAVE SIMILARLY IN SNOWFLAKE. ***/,
col2 NUMBER(1) /*** SSC-FDM-0006 - NUMBER TYPE COLUMN MAY NOT BEHAVE SIMILARLY IN SNOWFLAKE. ***/,
col3 NUMBER(10, 5) /*** SSC-FDM-0006 - NUMBER TYPE COLUMN MAY NOT BEHAVE SIMILARLY IN SNOWFLAKE. ***/,
col4 NUMBER(5) !!!RESOLVE EWI!!! /*** SSC-EWI-OR0092 - NUMBER DATATYPE NEGATIVE SCALE WAS REMOVED FROM OUTPUT ***/!!! /*** SSC-FDM-0006 - NUMBER TYPE COLUMN MAY NOT BEHAVE SIMILARLY IN SNOWFLAKE. ***/,
col5 NUMBER(5, 5) /*** SSC-FDM-OR0010 - NUMBER DATATYPE SMALLER PRECISION WAS INCREASED TO MATCH SCALE ***/ /*** SSC-FDM-0006 - NUMBER TYPE COLUMN MAY NOT BEHAVE SIMILARLY IN SNOWFLAKE. ***/
)
COMMENT = '{"origin":"sf_sc","name":"snowconvert","version":{"major":1, "minor":0},{"attributes":{"component":"oracle"}}'
;

INSERT INTO number_data_type_table(COL1) VALUES(100);

INSERT INTO number_data_type_table(COL2) VALUES(1.99999);

INSERT INTO number_data_type_table(COL3) VALUES(12345.12345);

INSERT INTO number_data_type_table(COL4) VALUES(16430.55555);

INSERT INTO number_data_type_table(COL4) VALUES(17550.55555);

INSERT INTO number_data_type_table(COL5) VALUES(0.00009);

INSERT INTO number_data_type_table(COL5) VALUES(0.000021);

INSERT INTO number_data_type_table(COL5) VALUES(0.012678912);
```

#### NUMBER ( default case )[¶](#number-default-case)

When the precision and the scale are not specified, the default values are the maximum
available`NUMBER(38, 127)` . The current transformation for the default case is `NUMBER(38,19).`

Warning

In Oracle, not defining Precision nor scale defaults to an “Undefined Precision and Scale”. It
behaves by storing the input “as received”, which means it can both deal with Integer and Floating
point numbers. We use **38, 18** to try to cover both of them, by using 20 for integers, and leaving
18 for floating-point digits.

##### Oracle[¶](#id48)

```
SELECT col1 FROM number_data_type_table;
```

##### Result[¶](#id49)

<!-- prettier-ignore -->
|col1|
|---|
|100|

##### Snowflake[¶](#id50)

```
SELECT col1 FROM
number_data_type_table;
```

##### Result[¶](#id51)

<!-- prettier-ignore -->
|col1|
|---|
|100.0000000000000000000|

#### NUMBER ( p )[¶](#number-p)

In this case, the precision will specify the number of digits that the number could have at the left
of the decimal point.

##### Oracle[¶](#id52)

```
SELECT col2 FROM number_data_type_table;
```

##### Result[¶](#id53)

<!-- prettier-ignore -->
|col2|
|---|
|2|

##### Snowflake[¶](#id54)

```
SELECT col2 FROM
number_data_type_table;
```

##### Result[¶](#id55)

<!-- prettier-ignore -->
|col2|
|---|
|2|

#### NUMBER ( p, s ) p > s[¶](#number-p-s-p-s)

In the case where the **s** is lower than the **p**, the precision will specify the number of digits
that the number could have. The scale will specify the number of significant digits to the right of
the decimal point, so the number of digits at the left of the decimal point will depend on the scale
specified.

##### Oracle[¶](#id56)

```
SELECT col3 FROM number_data_type_table;
```

##### Result[¶](#id57)

<!-- prettier-ignore -->
|col3|
|---|
|12345.12345|

##### Snowflake[¶](#id58)

```
SELECT col3 FROM
number_data_type_table;
```

##### Result[¶](#id59)

<!-- prettier-ignore -->
|col3|
|---|
|12345.12345|

#### NUMBER ( p, -s )[¶](#number-p-s)

A negative scale is the number of significant digits to the left of the decimal point, to but not
including the least significant digit. For the negative scale, the least significant digit is on the
left side of the decimal point, because the actual data is rounded to the specified number of places
to the left of the decimal point. The current transformation is to remove the negative scale.

##### Oracle[¶](#id60)

```
SELECT col4 FROM number_data_type_table;
```

##### Result[¶](#id61)

<!-- prettier-ignore -->
|col4|
|---|
|16400|
|17600|

##### Snowflake[¶](#id62)

```
SELECT col4 FROM
number_data_type_table;
```

##### Result[¶](#id63)

<!-- prettier-ignore -->
|col4|
|---|
|16431|
|17551|

#### NUMBER ( p, s ) s > p[¶](#number-p-s-s-p)

When the scale is greater than the precision, consider the following aspects:

- The number to insert could not have significant digits to the left of the decimal point. Only zero
  is available.
- The first digit to the right of the decimal point must be zero.
- The precision specifies the maximum number of significant digits to the right of the decimal
  point.

##### Oracle[¶](#id64)

```
SELECT col5 FROM number_data_type_table;
```

##### Result[¶](#id65)

<!-- prettier-ignore -->
|col5|
|---|
|0.00009|
|0.00002|
|0.01268|

##### Snowflake[¶](#id66)

```
SELECT col5 FROM
number_data_type_table;
```

##### Result[¶](#id67)

<!-- prettier-ignore -->
|col5|
|---|
|0.00009|
|0.00002|
|0.01268|

### Known Issues[¶](#id68)

#### 1. Scale value exceeds the maximum allowed by Snowflake[¶](#scale-value-exceeds-the-maximum-allowed-by-snowflake)

When specifying a scale greater than the maximum allowed in Snowflake (37) it is being changed
to 18. To get more information about this please go to the
[SSC-FDM-0006](../../../../general/technical-documentation/issues-and-troubleshooting/functional-difference/generalFDM.html#ssc-fdm-0006)
documentation.

##### 2. Negative scale[¶](#negative-scale)

Snowflake does not allow negative scale, so it is being removed. This could cause functional
inequivalence. To get more information about this issue please go to the
[SSC-EWI-0R0092](../../../../general/technical-documentation/issues-and-troubleshooting/conversion-issues/oracleEWI.html#ssc-ewi-or0092)
documentation.

### Recommendations[¶](#id69)

#### 1. UDF for NUMBER datatype Operations[¶](#udf-for-number-datatype-operations)

It is possible to migrate these operations manually by using the next UDF when performing arithmetic
operations to avoid incurring the issues noted:

##### UDF[¶](#udf)

```
CREATE OR REPLACE FUNCTION fixed_divide(a NUMBER(38,19), b NUMBER(38,19))
RETURNS NUMBER(38,19)
LANGUAGE JAVA
CALLED ON NULL INPUT
HANDLER='TestFunc.divide'
AS
'
import java.math.BigDecimal;
import java.math.RoundingMode;
class TestFunc {
public static BigDecimal divide(BigDecimal a, BigDecimal b) {
return a.divide(b,RoundingMode.HALF_UP);
}
}';
```

### Related EWIs[¶](#id70)

1. [SSC-EWI-OR0092](../../../../general/technical-documentation/issues-and-troubleshooting/conversion-issues/oracleEWI.html#ssc-ewi-or0092)
   Number datatype negative scale was removed from output.
2. [SSC-FDM-0006](../../../../general/technical-documentation/issues-and-troubleshooting/functional-difference/generalFDM.html#ssc-fdm-0006):
   Number type column may not behave similarly in Snowflake
3. [SSC-FDM-OR0010](../../../../general/technical-documentation/issues-and-troubleshooting/functional-difference/oracleFDM.html#ssc-fdm-or0010)
   Number datatype smaller precision was increased to match scale

## Floating-Point Numbers[¶](#floating-point-numbers)

### Description[¶](#id71)

> Floating-point numbers can have a decimal point anywhere from the first to the last digit or can
> have no decimal point at all. An exponent may optionally be used following the number to increase
> the range, for example, 1.777 e-20. A scale value is not applicable to floating-point numbers,
> because the number of digits that can appear after the decimal point is not restricted.Binary
> floating-point numbers are stored using binary precision (the digits 0 and
> 1)([Oracle Language Reference Floating-Point Numbers](https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/Data-Types.html#GUID-F579F4B8-EF13-4CAF-9B06-03B076861C41))

## BINARY_DOUBLE[¶](#binary-double)

### Description[¶](#id72)

> `BINARY_DOUBLE` is a 64-bit, double-precision floating-point number data type. Each
> `BINARY_DOUBLE` value requires 8 bytes. In a `BINARY_DOUBLE` column, floating-point numbers have
> binary precision. The binary floating-point numbers support the special values infinity and `NaN`
> (not a number).
> ([Oracle Language Reference Binary_Double data type](https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/Data-Types.html#GUID-12FE5221-9B49-4110-8D16-BF51BCED5562))

It is possible to specify floating-point numbers within the next limits:

- **Maximum positive finite value** = 1.79769313486231E+308
- **Minimum positive finite value** = 2.22507485850720E-308

### Sample Source Patterns[¶](#id73)

Please, consider the following table and its inserts for the example below:

#### Binary Double in Create Table[¶](#binary-double-in-create-table)

##### Oracle[¶](#id74)

```
CREATE TABLE binary_double_data_type_table
(
COL1 BINARY_DOUBLE
);

INSERT INTO binary_double_data_type_table VALUES(2.22507485850720E-308D);
INSERT INTO binary_double_data_type_table VALUES(1.79769313486231E+308D);
INSERT INTO binary_double_data_type_table VALUES('NaN');
```

##### Snowflake[¶](#id75)

```
CREATE OR REPLACE TABLE binary_double_data_type_table
(
COL1 FLOAT
)
COMMENT = '{"origin":"sf_sc","name":"snowconvert","version":{"major":1, "minor":0},{"attributes":{"component":"oracle"}}'
;

INSERT INTO binary_double_data_type_table
VALUES(2.22507485850720E-308);

INSERT INTO binary_double_data_type_table
VALUES(1.79769313486231E+308);

INSERT INTO binary_double_data_type_table
VALUES('NaN');
```

**Note:**

**‘NaN’** means **_Not a Number_**, this value is allowed by the`BINARY_DOUBLE` data type in Oracle
and by the`FLOAT`data type in Snowflake.

#### BINARY_DOUBLE -> FLOAT[¶](#binary-double-float)

Since the`BINARY_DOUBLE`data type is not supported by Snowflake it is being converted to FLOAT.

##### Oracle[¶](#id76)

```
SELECT * FROM binary_double_data_type_table;
```

##### Result[¶](#id77)

<!-- prettier-ignore -->
|col1|
|---|
|0|
|179769313486231000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000|
|NaN|

##### Snowflake[¶](#id78)

```
SELECT * FROM
binary_double_data_type_table;
```

##### Result[¶](#id79)

<!-- prettier-ignore -->
|col1|
|---|
|0|
|179769313486231000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000|
|NaN|

### Known Issues[¶](#id80)

#### 1. The BINARY_DOUBLE data type is not supported by Snowflake[¶](#the-binary-double-data-type-is-not-supported-by-snowflake)

The BINARY_DOUBLE data type is converted to FLOAT since it is not supported by Snowflake.

### Related EWIs[¶](#id81)

No related EWIs.

## BINARY_FLOAT[¶](#binary-float)

### Description[¶](#id82)

> `BINARY_FLOAT` is a 32-bit, single-precision floating-point number data type.
> Each`BINARY_FLOAT`value requires 4 bytes. In a `BINARY_FLOAT`column, floating-point numbers have
> binary precision. The binary floating-point numbers support the special values infinity and `NaN`
> (not a number).
> ([Oracle Language Reference Binary_Float data type](https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/Data-Types.html#GUID-CFE7487C-A4D0-4E90-A836-2697C45BDD10))

It is possible to specify floating-point numbers within the next limits:

- **Maximum positive finite value** = 3.40282E+38F
- **Minimum positive finite value** = 1.17549E-38F

### Sample Source Patterns[¶](#id83)

Please, consider the following table and its inserts for the example below:

#### Binary Float in Create Table[¶](#binary-float-in-create-table)

##### Oracle[¶](#id84)

```
CREATE TABLE binary_float_data_type_table
(
col1 BINARY_FLOAT
);

INSERT INTO binary_float_data_type_table VALUES(1.17549E-38F);
INSERT INTO binary_float_data_type_table VALUES(3.40282E+38F);
INSERT INTO binary_float_data_type_table VALUES('NaN');
```

##### Snowflake[¶](#id85)

```
CREATE OR REPLACE TABLE binary_float_data_type_table
(
col1 FLOAT
)
COMMENT = '{"origin":"sf_sc","name":"snowconvert","version":{"major":1, "minor":0},{"attributes":{"component":"oracle"}}'
;

INSERT INTO binary_float_data_type_table
VALUES(1.17549E-38);

INSERT INTO binary_float_data_type_table
VALUES(3.40282E+38);

INSERT INTO binary_float_data_type_table
VALUES('NaN');
```

**Note:**

**‘NaN’** means **_Not a Number_**, this value is allowed by the`BINARY_FLOAT` data type in Oracle
and by the`FLOAT`data type in Snowflake.

#### BINARY_FLOAT -> FLOAT[¶](#binary-float-float)

Since the`BINARY_FLOAT`data type is not supported by Snowflake it is being converted to FLOAT.

##### Oracle[¶](#id86)

```
SELECT * FROM binary_float_data_type_table;
```

##### Result[¶](#id87)

<!-- prettier-ignore -->
|col1|
|---|
|0|
|340282001837565600000000000000000000000|
|NaN|

##### Snowflake[¶](#id88)

```
SELECT * FROM binary_float_data_type_table;
```

##### Result[¶](#id89)

<!-- prettier-ignore -->
|col1|
|---|
|0|
|340282000000000000000000000000000000000|
|NaN|

### Known Issues[¶](#id90)

#### 1. The BINARY_FLOAT data type is not supported by Snowflake[¶](#the-binary-float-data-type-is-not-supported-by-snowflake)

The BINARY_FLOAT data type is converted to FLOAT since it is not supported by Snowflake.

### Related EWIs[¶](#id91)

No related EWIs.

## Datetime and Interval Data Types[¶](#datetime-and-interval-data-types)

> The datetime data types are `DATE`, `TIMESTAMP`, `TIMESTAMP` `WITH` `TIME` `ZONE`, and
> `TIMESTAMP` > `WITH` `LOCAL` `TIME` `ZONE`. Values of datetime data types are sometimes called
> datetimes. The interval data types are `INTERVAL` `YEAR` `TO` `MONTH` and `INTERVAL` `DAY` `TO` >
> `SECOND`. Values of interval data types are sometimes called intervals.
> ([Oracle SQL Language Reference Datetime and Interval Data Types](https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/Data-Types.html#GUID-7690645A-0EE3-46CA-90DE-C96DF5A01F8F))

## DATE Data Type[¶](#date-data-type)

### Description[¶](#id92)

> Oracle’s date data type stores both date and time information, however Snowflake’s date data type
> only stores date information.
> ([Oracle SQL Language Reference Date Data Type](https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/Data-Types.html#GUID-5405B652-C30E-4F4F-9D33-9A4CB2110F1B))

The default transformation for Oracle `DATE` is to Snowflake `TIMESTAMP`. You can add the
`disableDateAsTimestamp` flag (SnowConvert AI Command Line Interface) or **disable** the _Transform
Date as Timestamp_ setting (SnowConvert AI desktop application) in order to transform the `DATE`
type to `TIMESTAMP`. Keep in mind that Snowflake `DATE` only stores date information and Oracle
stores date and time information, if you want to avoid losing information you should transform
`DATE` to `TIMESTAMP`.

**Note:**

**Important Rounding Behavior Difference**: When performing operations between date/timestamp data
types and intervals involving seconds, Oracle does not round the seconds but preserves the precision
as specified, while Snowflake rounds the seconds to the nearest whole second. This difference in
rounding behavior can lead to different results.

### Sample Source Patterns[¶](#id93)

#### Date in Create Table[¶](#date-in-create-table)

##### Oracle[¶](#id94)

```
CREATE TABLE date_table
(
	date_col date
);

INSERT INTO date_table(date_col) VALUES (DATE '2010-10-10');
```

##### Snowflake without –disableDateAsTimestamp flag or with “Transform Date as Timestamp” setting enabled[¶](#snowflake-without-disabledateastimestamp-flag-or-with-transform-date-as-timestamp-setting-enabled)

```
CREATE OR REPLACE TABLE date_table
	(
		date_col TIMESTAMP /*** SSC-FDM-OR0042 - DATE TYPE COLUMN HAS A DIFFERENT BEHAVIOR IN SNOWFLAKE. ***/
	)
	COMMENT = '{"origin":"sf_sc","name":"snowconvert","version":{"major":1, "minor":0},"attributes":{"component":"oracle"}}'
	;

	INSERT INTO date_table(date_col) VALUES (DATE '2010-10-10');
```

##### Snowflake with –disableDateAsTimestamp flag or with “Transform Date as Timestamp” setting disabled[¶](#snowflake-with-disabledateastimestamp-flag-or-with-transform-date-as-timestamp-setting-disabled)

```
CREATE OR REPLACE TABLE date_table
	(
		date_col date
	)
	COMMENT = '{"origin":"sf_sc","name":"snowconvert","version":{"major":1, "minor":0},{"attributes":{"component":"oracle"}}'
	;

	INSERT INTO date_table(date_col) VALUES (DATE '2010-10-10');
```

#### Retrieving data from a Date column[¶](#retrieving-data-from-a-date-column)

##### Oracle[¶](#id95)

```
SELECT date_col FROM date_table;
```

###### Result[¶](#id96)

<!-- prettier-ignore -->
|DATE_COL|
|---|
|2010-10-10 00:00:00.000|

##### Snowflake[¶](#id97)

```
SELECT date_col FROM
date_table;
```

###### Result[¶](#id98)

<!-- prettier-ignore -->
|DATE_COL|
|---|
|2010-10-10 00:00:00.000|

###### Result with disableDateAsTimestamp flag[¶](#result-with-disabledateastimestamp-flag)

<!-- prettier-ignore -->
|DATE_COL|
|---|
|2010-10-10|

### Known Issues[¶](#id99)

#### 1. Input and output format may differ between languages[¶](#input-and-output-format-may-differ-between-languages)

In Snowflake, _`DATE`_ input and output formats depend on the _`DATE_INPUT_FORMAT`_ and
_`DATE_OUTPUT_FORMAT`_ session variables. Insertions may fail because the `DATE_INPUT_FORMAT`
enforces the user to use a specific format when a date is added by text. You can modify those
variables using the following syntax.

```
ALTER SESSION SET DATE_INPUT_FORMAT = 'YYYY-DD-MM' DATE_OUTPUT_FORMAT = 'DD-MM-YYYY';
```

### Related EWIs[¶](#id100)

1. [SSC-FDM-OR0042](../../../../general/technical-documentation/issues-and-troubleshooting/functional-difference/oracleFDM.html#ssc-fdm-or0042):
   Date Type Transformed To Timestamp Has A Different Behavior

## INTERVAL DAY TO SECOND Data Type[¶](#interval-day-to-second-data-type)

### Description[¶](#id101)

> INTERVAL DAY TO SECOND stores a period of time in terms of days, hours, minutes, and seconds.
> ([Oracle SQL Language Reference INTERVAL DAY TO SECOND Data Type](https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/Data-Types.html#GUID-B03DD036-66F8-4BD3-AF26-6D4433EBEC1C))

There is no equivalent for this data type in Snowflake, it is currently transformed to `VARCHAR`.

```
INTERVAL DAY [(day_precision)] TO SECOND [(fractional_seconds_precision)]
```

### Sample Source Patterns[¶](#id102)

#### Interval Day to Second in Create Table[¶](#interval-day-to-second-in-create-table)

##### Oracle[¶](#id103)

```
CREATE TABLE interval_day_to_second_table
(
	interval_day_col1 interval day to second,
	interval_day_col2 interval day(1) to second(4)
);

INSERT INTO interval_day_to_second_table(interval_day_col1) VALUES ( INTERVAL '1 2:3:4.56' DAY TO SECOND );
INSERT INTO interval_day_to_second_table(interval_day_col2) VALUES ( INTERVAL '1 2:3:4.56' DAY(1) TO SECOND(4) );
```

##### Snowflake[¶](#id104)

```
CREATE OR REPLACE TABLE interval_day_to_second_table
	(
		interval_day_col1 VARCHAR(20) !!!RESOLVE EWI!!! /*** SSC-EWI-0036 - INTERVAL day to second DATA TYPE CONVERTED TO VARCHAR ***/!!!,
		interval_day_col2 VARCHAR(20) !!!RESOLVE EWI!!! /*** SSC-EWI-0036 - INTERVAL day(1) to second(4) DATA TYPE CONVERTED TO VARCHAR ***/!!!
	)
	COMMENT = '{"origin":"sf_sc","name":"snowconvert","version":{"major":1, "minor":0},{"attributes":{"component":"oracle"}}'
	;

	INSERT INTO interval_day_to_second_table(interval_day_col1) VALUES ('1d, 2h, 3m, 4s, 56ms');

	INSERT INTO interval_day_to_second_table(interval_day_col2) VALUES ('1d, 2h, 3m, 4s, 56ms');
```

The Interval value is transformed to a supported Snowflake format and then inserted as text inside
the column. Since Snowflake does not support **Interval** as a data type, it is only supported in
arithmetic operations. In order to use the value, it needs to be extracted and used as an
[Interval constant](https://docs.snowflake.com/en/sql-reference/data-types-datetime.html#interval-constants)
(if possible).

**Original Oracle value:** `INTERVAL '1 2:3:4.567' DAY TO SECOND`

**Value stored in Snowflake column:** `'1d, 2h, 3m, 4s, 567ms'`

**Value as Snowflake Interval constant:** `INTERVAL '1d, 2h, 3m, 4s, 567ms'`

#### Retrieving data from an Interval Day to Second column[¶](#retrieving-data-from-an-interval-day-to-second-column)

##### Oracle[¶](#id105)

```
SELECT * FROM interval_day_to_second_table;
```

###### Result[¶](#id106)

<!-- prettier-ignore -->
|INTERVAL_DAY_COL1|INTERVAL_DAY_COL2|
|---|---|
|1 2:3:4.567||
||1 2:3:4.567|

##### Snowflake[¶](#id107)

```
SELECT * FROM
interval_day_to_second_table;
```

###### Result[¶](#id108)

<!-- prettier-ignore -->
|INTERVAL_DAY_COL1|INTERVAL_DAY_COL2|
|---|---|
|1d, 2h, 3m, 4s, 56ms||
||1d, 2h, 3m, 4s, 56ms|

### Known Issues[¶](#id109)

#### 1. Only arithmetic operations are supported[¶](#only-arithmetic-operations-are-supported)

Snowflake Intervals have several limitations. Only arithmetic operations between `DATE` or
`TIMESTAMP` and
[Interval Constants](https://docs.snowflake.com/en/sql-reference/data-types-datetime.html#interval-constants)
are supported, every other scenario is not supported.

### Related EWIs[¶](#id110)

1. [SSC-EWI-0036](../../../../general/technical-documentation/issues-and-troubleshooting/conversion-issues/generalEWI.html#ssc-ewi-0036):
   Data type converted to another data type.

## INTERVAL YEAR TO MONTH Data Type[¶](#interval-year-to-month-data-type)

### Description[¶](#id111)

> INTERVAL YEAR TO MONTH stores a period of time using the YEAR and MONTH datetime fields. There is
> no equivalent in Snowflake so it is transformed to Varchar
> ([Oracle SQL Language Reference INTERVAL YEAR TO MONTH Data Type](https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/Data-Types.html#GUID-ED59E1B3-BA8D-4711-B5C8-B0199C676A95))

There is no equivalent for this data type in Snowflake, it is currently transformed to VARCHAR.

```
INTERVAL YEAR [(year_precision)] TO MONTH
```

### Sample Source Patterns[¶](#id112)

#### Interval Year To Month in Create Table[¶](#interval-year-to-month-in-create-table)

##### Oracle[¶](#id113)

```
CREATE TABLE interval_year_to_month_table
(
	interval_year_col1 interval year to month,
	interval_year_col2 interval year(4) to month
);

INSERT INTO interval_year_to_month_table(interval_year_col1) VALUES ( INTERVAL '1-2' YEAR TO MONTH );
INSERT INTO interval_year_to_month_table(interval_year_col2) VALUES ( INTERVAL '1000-11' YEAR(4) TO MONTH );
```

##### Snowflake[¶](#id114)

```
CREATE OR REPLACE TABLE interval_year_to_month_table
	(
		interval_year_col1 VARCHAR(20) !!!RESOLVE EWI!!! /*** SSC-EWI-0036 - INTERVAL year to month DATA TYPE CONVERTED TO VARCHAR ***/!!!,
		interval_year_col2 VARCHAR(20) !!!RESOLVE EWI!!! /*** SSC-EWI-0036 - INTERVAL year(4) to month DATA TYPE CONVERTED TO VARCHAR ***/!!!
	)
	COMMENT = '{"origin":"sf_sc","name":"snowconvert","version":{"major":1, "minor":0},{"attributes":{"component":"oracle"}}'
	;

	INSERT INTO interval_year_to_month_table(interval_year_col1) VALUES ('1y, 2mm');

	INSERT INTO interval_year_to_month_table(interval_year_col2) VALUES ('1000y, 11mm');
```

The Interval value is transformed to a supported Snowflake format and then inserted as text inside
the column. Since Snowflake does not support **Interval** as a data type, it is only supported in
arithmetic operations. In order to use the value, it needs to be extracted and used as an
[Interval constant](https://docs.snowflake.com/en/sql-reference/data-types-datetime.html#interval-constants)
(if possible).

**Original Oracle value:** `INTERVAL '1-2' YEAR TO MONTH`

**Value stored in Snowflake column:** `'1y, 2m'`

**Value as Snowflake Interval constant:** `INTERVAL '1y, 2m'`

#### Retrieving data from an Interval Year To Month column[¶](#retrieving-data-from-an-interval-year-to-month-column)

##### Oracle[¶](#id115)

```
SELECT * FROM interval_year_to_month_table;
```

###### Result[¶](#id116)

<!-- prettier-ignore -->
|INTERVAL_YEAR_COL1|INTERVAL_YEAR_COL2|
|---|---|
|1-2||
||1000-11|

##### Snowflake[¶](#id117)

```
SELECT * FROM
interval_year_to_month_table;
```

###### Result[¶](#id118)

<!-- prettier-ignore -->
|INTERVAL_YEAR_COL1|INTERVAL_YEAR_COL2|
|---|---|
|1y, 2m||

```
              |1000y, 11m        |
```

### Known Issues[¶](#id119)

#### 1. Only arithmetic operations are supported[¶](#id120)

Snowflake Intervals have several limitations. Only arithmetic operations between `DATE` or
`TIMESTAMP` and
[Interval Constants](https://docs.snowflake.com/en/sql-reference/data-types-datetime.html#interval-constants)
are supported, every other scenario is not supported.

### Related EWIs[¶](#id121)

- [SSC-EWI-0036](../../../../general/technical-documentation/issues-and-troubleshooting/conversion-issues/generalEWI.html#ssc-ewi-0036):
  Data type converted to another data type.

## TIMESTAMP Data Type[¶](#timestamp-data-type)

### Description[¶](#id122)

> The TIMESTAMP data type is an extension of the DATE data type. It stores the year, month, and day
> of the DATE data type, plus hour, minute, and second values.
> ([Oracle SQL Language Reference Timestamp Data Type](https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/Data-Types.html#GUID-94A82966-D380-4583-9AF1-AEE681881E64))

Both Oracle and Snowflake `TIMESTAMP` data types have the same precision range (0-9) but different
default values. In Oracle, the default precision value is 6 and in Snowflake is 9.

However, there is a difference in behavior when an inserted value exceeds the set precision. Oracle
rounds up the exceeding decimals, while Snowflake just trims the values.

```
TIMESTAMP [(fractional_seconds_precision)]
```

### Sample Source Patterns[¶](#id123)

#### Timestamp in Create Table[¶](#timestamp-in-create-table)

##### Oracle[¶](#id124)

```
CREATE TABLE timestamp_table
(
	timestamp_col1 TIMESTAMP,
	timestamp_col2 TIMESTAMP(7)
);

INSERT INTO timestamp_table(timestamp_col1, timestamp_col2) VALUES (TIMESTAMP '2010-10-10 12:00:00', TIMESTAMP '2010-10-10 12:00:00');
```

##### Snowflake[¶](#id125)

```
CREATE OR REPLACE TABLE timestamp_table
	(
		timestamp_col1 TIMESTAMP(6),
		timestamp_col2 TIMESTAMP(7)
	)
	COMMENT = '{"origin":"sf_sc","name":"snowconvert","version":{"major":1, "minor":0},{"attributes":{"component":"oracle"}}'
	;

	INSERT INTO timestamp_table(timestamp_col1, timestamp_col2) VALUES (TIMESTAMP '2010-10-10 12:00:00', TIMESTAMP '2010-10-10 12:00:00');
```

#### Retrieving data from a Timestamp column[¶](#retrieving-data-from-a-timestamp-column)

##### Oracle[¶](#id126)

```
SELECT * FROM timestamp_table;
```

###### Result[¶](#id127)

<!-- prettier-ignore -->
|TIMESTAMP_COL1|TIMESTAMP_COL2|
|---|---|
|2010-10-10 12:00:00.000|2010-10-10 12:00:00.000|

##### Snowflake[¶](#id128)

```
SELECT * FROM
timestamp_table;
```

###### Result[¶](#id129)

<!-- prettier-ignore -->
|TIMESTAMP_COL1|TIMESTAMP_COL2|
|---|---|
|2010-10-10 12:00:00.000|2010-10-10 12:00:00.000|

### Known Issues[¶](#id130)

No issues were found.

### Related EWIs[¶](#id131)

No related EWIs.

## TIMESTAMP WITH LOCAL TIME ZONE Data Type[¶](#timestamp-with-local-time-zone-data-type)

### Description[¶](#id132)

> It differs from TIMESTAMP WITH TIME ZONE in that data stored in the database is normalized to the
> database time zone, and the time zone information is not stored as part of the column
> data..([Oracle SQL Language Reference Timestamp with Local Time Zone Data Type](https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/Data-Types.html#GUID-E7CA339A-2093-4FE4-A36E-1D09593591D3))

The Snowflake equivalent is
[TIMESTAMP_LTZ](https://docs.snowflake.com/en/sql-reference/data-types-datetime.html#timestamp-ltz-timestamp-ntz-timestamp-tz).

For more information, see also the [TIMESTAMP](#timestamp-data-type) section.

```
TIMESTAMP [(fractional_seconds_precision)] WITH LOCAL TIME ZONE
```

### Sample Source Patterns[¶](#id133)

#### Timestamp with Time Zone in Create Table[¶](#timestamp-with-time-zone-in-create-table)

##### Oracle[¶](#id134)

```
CREATE TABLE timestamp_with_local_time_zone_table
(
	timestamp_col1 TIMESTAMP(5) WITH LOCAL TIME ZONE
);

INSERT INTO timestamp_with_local_time_zone_table(timestamp_col1) VALUES (TIMESTAMP '2010-10-10 12:00:00');
INSERT INTO timestamp_with_local_time_zone_table(timestamp_col1) VALUES (TIMESTAMP '2010-10-10 12:00:00 -08:00');
```

##### Snowflake[¶](#id135)

```
CREATE OR REPLACE TABLE timestamp_with_local_time_zone_table
	(
		timestamp_col1 TIMESTAMP_LTZ(5)
	)
	COMMENT = '{"origin":"sf_sc","name":"snowconvert","version":{"major":1, "minor":0},{"attributes":{"component":"oracle"}}'
	;

	INSERT INTO timestamp_with_local_time_zone_table(timestamp_col1) VALUES (TIMESTAMP '2010-10-10 12:00:00');

	INSERT INTO timestamp_with_local_time_zone_table(timestamp_col1) VALUES (TIMESTAMP '2010-10-10 12:00:00 -08:00');
```

#### Retrieving data from a Timestamp with Local Time Zone column[¶](#retrieving-data-from-a-timestamp-with-local-time-zone-column)

##### Oracle[¶](#id136)

```
SELECT * FROM timestamp_with_local_time_zone_table;
```

##### Result[¶](#id137)

<!-- prettier-ignore -->
|TIMESTAMP_COL1|
|---|
|2010-10-10 18:00:00.000|
|2010-10-10 20:00:00.000|

##### Snowflake[¶](#id138)

```
SELECT * FROM
timestamp_with_local_time_zone_table;
```

##### Result[¶](#id139)

<!-- prettier-ignore -->
|TIMESTAMP_COL1|
|---|
|2010-10-10 12:00:00.000 -0700|
|2010-10-10 12:00:00.000 -0700|

**Note:**

Note that the results are different in both engines because each database is set with a different
time zone. The Oracle timezone is ‘+00:00’ and the Snowflake timezone is ‘America/Los_Angeles’.

Use the following syntax to change the default timezone of the database:

```
ALTER account SET timezone = timezone_string;
```

### Known Issues[¶](#id140)

#### 1. Default database timezone[¶](#default-database-timezone)

The operations with this kind of data type will be affected by the database timezone, the results
may be different. You can check the default timezone using the following queries:

##### Oracle[¶](#id141)

```
SELECT dbtimezone FROM dual;
```

##### Snowflake[¶](#id142)

```
SELECT dbtimezone FROM dual;
```

##### 2. Oracle Timestamp with local timezone behavior[¶](#oracle-timestamp-with-local-timezone-behavior)

When operating timestamps with local timezone data types, Oracle converts the timestamps to the
default timezone of the database. In order to emulate this behavior in Snowflake, the
TIMESTAMP_TYPE_MAPPING session parameter should be set to ‘TIMESTAMP_LTZ’.

```
ALTER SESSION SET TIMESTAMP_TYPE_MAPPING = 'TIMESTAMP_LTZ';
```

##### 3. Timestamp formats may be different[¶](#timestamp-formats-may-be-different)

Snow Convert does not perform any conversion for the date/timestamps format strings, so there may be
errors when deploying the code. Example:

##### Oracle[¶](#id143)

```
INSERT INTO timestamp_with_local_time_zone_table (timestamp_col1) VALUES (TIMESTAMP '2010-10-10 12:00:00 -8:00');
```

##### Snowflake[¶](#id144)

```
INSERT INTO timestamp_with_local_time_zone_table(timestamp_col1) VALUES (TIMESTAMP '2010-10-10 12:00:00 -8:00');
```

Warning

The query will fail in Snowflake because the default timestamp input format does not recognize
‘-8:00’ as a valid UTC offset. It should be replaced with ‘0800’ or ‘-08:00’ in order to get the
same result.

### Related EWIs[¶](#id145)

No related EWIs.

## TIMESTAMP WITH TIME ZONE Data Type[¶](#timestamp-with-time-zone-data-type)

### Description[¶](#id146)

> TIMESTAMP WITH TIME ZONE is a variant of TIMESTAMP that includes a time zone region name or a time
> zone offset in its value. The Snowflake equivalent is
> TIMESTAMP_TZ.([Oracle SQL Language Reference Timestamp with Time Zone Data Type](https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/Data-Types.html#GUID-BE23545B-469A-4A57-8D13-505F2F5DB706))

The Snowflake equivalent is
[TIMESTAMP_TZ](https://docs.snowflake.com/en/sql-reference/data-types-datetime.html#timestamp-ltz-timestamp-ntz-timestamp-tz).

For more information, see also the [TIMESTAMP](#timestamp-data-type) section.

```
TIMESTAMP [(fractional_seconds_precision)] WITH TIME ZONE
```

### Sample Source Patterns[¶](#id147)

#### Timestamp with Time Zone in Create Table[¶](#id148)

##### Oracle[¶](#id149)

```
CREATE TABLE timestamp_with_time_zone_table
(
	timestamp_col1 TIMESTAMP(5) WITH TIME ZONE
);


INSERT INTO timestamp_with_time_zone_table(timestamp_col1) VALUES (TIMESTAMP '2010-10-10 12:00:00');
```

##### Snowflake[¶](#id150)

```
CREATE OR REPLACE TABLE timestamp_with_time_zone_table
	(
		timestamp_col1 TIMESTAMP_TZ(5)
	)
	COMMENT = '{"origin":"sf_sc","name":"snowconvert","version":{"major":1, "minor":0},{"attributes":{"component":"oracle"}}'
	;

	INSERT INTO timestamp_with_time_zone_table(timestamp_col1) VALUES (TIMESTAMP '2010-10-10 12:00:00');
```

#### Retrieving data from a Timestamp with Time Zone column[¶](#retrieving-data-from-a-timestamp-with-time-zone-column)

##### Oracle[¶](#id151)

```
SELECT * FROM timestamp_with_time_zone_table;
```

##### Result[¶](#id152)

<!-- prettier-ignore -->
|TIMESTAMP_COL1|
|---|
|2010-10-10 12:00:00.000 -0600|

##### Snowflake[¶](#id153)

```
SELECT * FROM
timestamp_with_time_zone_table;
```

##### Result[¶](#id154)

<!-- prettier-ignore -->
|TIMESTAMP_COL1|
|---|
|2010-10-10 12:00:00.000 -0700|

**Note:**

Note that the timezone is different in both engines because when the timezone is not specified, the
default timezone of the database is added.

Use the following syntax to change the default timezone of the database:

```
ALTER account SET sqtimezone = timezone_string;
```

### Known Issues[¶](#id155)

#### 1. Timestamp formats may be different[¶](#id156)

Snow Convert does not perform any conversion for the date/timestamps format strings, so there may be
errors when deploying the code. Example:

##### Oracle[¶](#id157)

```
INSERT INTO timestamp_with_time_zone_table(timestamp_col1) VALUES (TIMESTAMP '2010-10-10 12:00:00 -8:00');
```

##### Snowflake[¶](#id158)

```
INSERT INTO timestamp_with_time_zone_table(timestamp_col1) VALUES (TIMESTAMP '2010-10-10 12:00:00 -8:00');
```

Warning

The query will fail in Snowflake because the default timestamp input format does not recognize
‘-8:00’ as a valid UTC offset. It should be replaced with ‘-0800’ or ‘-08:00’ in order to get the
same result.

### Related EWIs[¶](#id159)

No related EWIs.

## Datetime Arithmetic[¶](#datetime-arithmetic)

This content explains the current transformation for some arithmetic operations between datetime
types.

### Description[¶](#id160)

In Oracle, some arithmetic operations could be performed between DateTime types, like addition,
subtraction, multiplication, and division. Currently, SnowConvert AI can resolve some cases of
addition and subtraction. These cases are explained below.

### Sample Source Patterns[¶](#id161)

This is a summary of the current transformation for the different combinations of the addition and
subtraction operations with date, timestamps, number, and unknown types.

**Note:**

**Consider the next table for the examples below.**

#### Oracle[¶](#id162)

```
CREATE OR REPLACE TABLE TIMES (
AsTimeStamp TIMESTAMP(6),
AsTimestampTwo TIMESTAMP(6),
AsDate TIMESTAMP,
AsDateTwo TIMESTAMP
);

INSERT INTO TIMES
VALUES (
TO_TIMESTAMP('05/11/21, 11:00 A.M.', 'dd/mm/yy, hh:mi A.M.'),
TO_TIMESTAMP('05/11/21, 10:00 A.M.', 'dd/mm/yy, hh:mi A.M.'),
TO_DATE('06/11/21', 'dd/mm/yy'),
TO_DATE('05/11/21', 'dd/mm/yy'));
```

##### Snowflake[¶](#id163)

```
CREATE OR REPLACE TABLE TIMES (
 AsTimeStamp TIMESTAMP(6),
 AsTimestampTwo TIMESTAMP(6),
 AsDate TIMESTAMP(6),
 AsDateTwo TIMESTAMP(6)
 )
 COMMENT = '{"origin":"sf_sc","name":"snowconvert","version":{"major":1, "minor":0},{"attributes":{"component":"oracle"}}'
 ;

 INSERT INTO TIMES
 VALUES (
TO_TIMESTAMP('05/11/21, 11:00 A.M.', 'dd/mm/yy, hh:mi A.M.'),
TO_TIMESTAMP('05/11/21, 10:00 A.M.', 'dd/mm/yy, hh:mi A.M.'),
TO_DATE('06/11/21', 'dd/mm/yy'),
TO_DATE('05/11/21', 'dd/mm/yy'));
```

### Addition[¶](#addition)

#### Combination Matrix[¶](#combination-matrix)

This is a summary of how the migrator resolves the addition operations for the different
combinations with date, timestamps, number, and unknown types.

<!-- prettier-ignore -->
|Addition|Date|Timestamp|Number|Interval|Unknown|Float|
|---|---|---|---|---|---|---|
|**Date**|INVALID|INVALID|Date + Interval day|Date + Interval IntervalUnit|DATEADD_UDF|DATEADD_UDF|
|**Timestamp**|INVALID|INVALID|Timestamp + Interval day|Timestamp + Interval IntervalUnit|DATEADD_UDF|DATEADD_UDF|
|**Number**|Date + Interval day|Timestamp + Interval day|Number + Number|INVALID|[SSC-EWI-OR0036](../../../../general/technical-documentation/issues-and-troubleshooting/conversion-issues/oracleEWI.html#ssc-ewi-or0036)|Number + Float|
|**Interval**|Date + Interval IntervalUnit|Timestamp + Interval IntervalUnit|INVALID|[SSC-EWI-OR0036](../../../../general/technical-documentation/issues-and-troubleshooting/conversion-issues/oracleEWI.html#ssc-ewi-or0036)|Unknown + Interval IntervalUnit|INVALID|
|**Unknown**|DATEADD_UDF|DATEADD_UDF|Unknown + Number|Unknown + Interval IntervalUnit|[SSC-EWI-OR0036](../../../../general/technical-documentation/issues-and-troubleshooting/conversion-issues/oracleEWI.html#ssc-ewi-or0036)|[SSC-EWI-OR0036](../../../../general/technical-documentation/issues-and-troubleshooting/conversion-issues/oracleEWI.html#ssc-ewi-or0036)|
|**Float**|DATEADD_UDF|DATEADD_UDF|Float + Number|INVALID|[SSC-EWI-OR0036](../../../../general/technical-documentation/issues-and-troubleshooting/conversion-issues/oracleEWI.html#ssc-ewi-or0036)|Float + Float|

**Note:**

An Unknown Type column is the result of the migrator being unable to establish the data type that
the column contains. This can happen for many reasons, for example missing DDLs for the tables being
operated on, columns resulting from operations on views, CTES or subqueries, etc.

Warning

By default, Snow Convert migrates operations of type Date/Timestamp + Interval to the native
Snowflake operations, but in some cases may be useful to use
[UDF](../../functions/custom_udfs.html#dateadd-udf-interval) instead. Further details about this UDF
can be found [here](#interval-udfs-vs-snowflake-native-interval-operation).

The different paths that the migrator can use for resolving the add operations will be explained
below:

#### Invalid[¶](#invalid)

Certain combinations are not valid to perform addition operations in Oracle:

##### Oracle[¶](#id164)

```
SELECT AsDate + AsDateTwo From TIMES;

SELECT AsDate + AsTimeStamp From TIMES;
```

##### Result[¶](#id165)

```
SQL Error [975] [42000]: ORA-00975: date + date not allowed

SQL Error [30087] [99999]: ORA-30087: Adding two datetime values is not allowed
```

#### Date + Interval day[¶](#date-interval-day)

This is the current transformation for the addition operation between a date type and a number (and
vice versa). For example

##### Oracle[¶](#id166)

```
SELECT AsDate + 1 FROM TIMES;

SELECT 1 + AsDate FROM TIMES;
```

##### Result[¶](#id167)

<!-- prettier-ignore -->
|ASDATE+1|
|---|
|2021-11-07 00:00:00.000|

<!-- prettier-ignore -->
|1+ASDATE|
|---|
|2021-11-07 00:00:00.000|

##### Snowflake[¶](#id168)

```
SELECT
!!!RESOLVE EWI!!! /*** SSC-EWI-OR0036 - TYPES RESOLUTION ISSUES, ARITHMETIC OPERATION '+' MAY NOT BEHAVE CORRECTLY BETWEEN unknown AND Number ***/!!!
 AsDate + 1 FROM
 TIMES;


SELECT
 !!!RESOLVE EWI!!! /*** SSC-EWI-OR0036 - TYPES RESOLUTION ISSUES, ARITHMETIC OPERATION '+' MAY NOT BEHAVE CORRECTLY BETWEEN Number AND unknown ***/!!! 1 + AsDate FROM
 TIMES;
```

##### Result[¶](#id169)

<!-- prettier-ignore -->
|ASDATE + INTERVAL ‘1 DAY’|
|---|
|2021-11-07|

#### Timestamp + Interval day[¶](#timestamp-interval-day)

This is the current transformation for the addition operation between a timestamp type and a number
(and vice versa). For example

##### Oracle[¶](#id170)

```
SELECT AsTimestamp + 1 FROM TIMES;

SELECT 1 + AsTimestamp FROM TIMES;
```

##### Result[¶](#id171)

<!-- prettier-ignore -->
|ASTIMESTAMP+1|
|---|
|2021-11-06 11:00:00.000|

<!-- prettier-ignore -->
|1+ASTIMESTAMP|
|---|
|2021-11-06 11:00:00.000|

**Note:**

Note: In Oracle, both DATE and TIMESTAMP columns contain a time component, but Oracle has used the
format mask specified by the NLS_DATE_FORMAT parameter to decide how to implicitly convert the date
to a string, that is why when performing some operations between TIMESTAMP and Intervals, he result
could be shown as DATE, hiding the time component, unless the NLS_DATE_FORMAT parameter is changed.

##### Snowflake[¶](#id172)

```
SELECT
!!!RESOLVE EWI!!! /*** SSC-EWI-OR0036 - TYPES RESOLUTION ISSUES, ARITHMETIC OPERATION '+' MAY NOT BEHAVE CORRECTLY BETWEEN unknown AND Number ***/!!!
 AsTimestamp + 1 FROM
 TIMES;


SELECT
 !!!RESOLVE EWI!!! /*** SSC-EWI-OR0036 - TYPES RESOLUTION ISSUES, ARITHMETIC OPERATION '+' MAY NOT BEHAVE CORRECTLY BETWEEN Number AND unknown ***/!!! 1 + AsTimestamp FROM
 TIMES;
```

##### Result[¶](#id173)

<!-- prettier-ignore -->
|ASTIMESTAMP + INTERVAL ‘1 DAY’|
|---|
|2021-11-06 11:00:00.000|

#### DATEADD_UDF[¶](#dateadd-udf)

For those cases where there is an addition operation between a date or timestamp type and an unknown
type, a user-defined function (UDF) is added. The current UDF implementation can be found
[here](../../functions/custom_udfs.html#dateadd-udf-interval). The UDF is located in the UDFs
folder. For example:

**Note:**

For the following examples, a subquery will be used, trying to simulate the Unknown Type column

##### Oracle[¶](#id174)

```
SELECT AsDate + (SELECT EXTRACT(DAY FROM AsTimestampTwo) FROM TIMES) FROM TIMES;

SELECT AsTimestamp + (SELECT EXTRACT(DAY FROM AsTimestampTwo) FROM TIMES) FROM TIMES;
```

##### Result[¶](#id175)

<!-- prettier-ignore -->
|ASDATE+(SELECTEXTRACT(DAYFROMASTIMESTAMPTWO)FROMTIMES)|
|---|
|2021-11-11 00:00:00.000|

<!-- prettier-ignore -->
|ASTIMESTAMP+(SELECTEXTRACT(DAYFROMASTIMESTAMPTWO)FROMTIMES)|
|---|
|2021-11-10 11:00:00.000|

##### Snowflake[¶](#id176)

```
SELECT AsDate + (SELECT EXTRACT(DAY FROM AsTimestampTwo) FROM
TIMES
) FROM
TIMES;

SELECT AsTimestamp + (SELECT EXTRACT(DAY FROM AsTimestampTwo) FROM
TIMES
) FROM
TIMES;
```

##### Result[¶](#id177)

<!-- prettier-ignore -->
|PUBLIC.DATEADD_UDF( ASDATE, (SELECT EXTRACT(DAY FROM ASTIMESTAMPTWO) FROM PUBLIC.TIMES))|
|---|
|2021-11-11|

<!-- prettier-ignore -->
|PUBLIC.DATEADD_UDF( ASTIMESTAMP, (SELECT EXTRACT(DAY FROM ASTIMESTAMPTWO) FROM PUBLIC.TIMES))|
|---|
|2021-11-10 11:00:00.000|

### Subtraction[¶](#subtraction)

#### Combination Matrix[¶](#id178)

<!-- prettier-ignore -->
|Subtraction|Date|Timestamp|Number|Interval|Unknown|Float|
|---|---|---|---|---|---|---|
|**Date**|DATEDIFF|TIMESTAMP_DIFF\_\_\_UDF|Date - Interval day|Date - Interval IntervalUnit|DATEDIFF_UDF|DATEDIFF_UDF|
|**Timestamp**|TIMESTAMP_DIFF\_\_\_UDF|TIMESTAMP_DIFF\_\_\_UDF|Timestamp - Interval day|Timestamp - Interval IntervalUnit|DATEDIFF_UDF|DATEDIFF_UDF|
|**Number**|INVALID|INVALID|Number - Number|INVALID|[SSC-EWI-OR0036](../../../../general/technical-documentation/issues-and-troubleshooting/conversion-issues/oracleEWI.html#ssc-ewi-or0036)|Number - Float|
|**Interval**|INVALID|INVALID|INVALID|[SSC-EWI-OR0036](../../../../general/technical-documentation/issues-and-troubleshooting/conversion-issues/oracleEWI.html#ssc-ewi-or0036)|Unknown - Interval IntervalUnit|NOT SUPPORTED IN ORACLE|
|**Unknown**|DATEDIFF_UDF|DATEDIFF_UDF|[SSC-EWI-OR0036](../../../../general/technical-documentation/issues-and-troubleshooting/conversion-issues/oracleEWI.html#ssc-ewi-or0036)|Unknown - Interval IntervalUnit|[SSC-EWI-OR0036](../../../../general/technical-documentation/issues-and-troubleshooting/conversion-issues/oracleEWI.html#ssc-ewi-or0036)|[SSC-EWI-OR0036](../../../../general/technical-documentation/issues-and-troubleshooting/conversion-issues/oracleEWI.html#ssc-ewi-or0036)|
|**Float**|DATEDIFF_UDF|DATEDIFF_UDF|Float - Number|NOT SUPPORTED IN ORACLE|[SSC-EWI-OR0036](../../../../general/technical-documentation/issues-and-troubleshooting/conversion-issues/oracleEWI.html#ssc-ewi-or0036)|Float - Float|

**Note:**

An Unknown Type column is the result of the migrator being unable to establish the data type that
the column contains. This can happen for many reasons, for example missing DDLs for the tables being
operated on, columns resulting from operations on views, CTES or subqueries, etc.

Warning

By default, Snow Convert migrates operations of type Date/Timestamp + Interval to the native
Snowflake operations, but in some cases may be useful to use
[UDF](../../functions/custom_udfs.html#datediff-udf-interval) instead. Further details about this
UDF can be found [here](#interval-udfs-vs-snowflake-native-interval-operation).

The different paths that the migrator can use for resolving the subtract operations will be
explained below:

#### Invalid[¶](#id179)

Certain combinations are not valid to perform subtraction operations in Oracle:

##### Oracle[¶](#id180)

```
SELECT 1 - AsDate FROM TIMES;

SELECT 1 - AsTimestamp FROM TIMES;
```

##### Result[¶](#id181)

```
SQL Error [932] [42000]: ORA-00932: inconsistent datatypes: expected NUMBER got DATE

SQL Error [932] [42000]: ORA-00932: inconsistent datatypes: expected NUMBER got TIMESTAMP
```

#### DATEDIFF[¶](#datediff)

The subtraction between two operands of date type is converted to the Snowflake DATEDIFF function,
using as a time unit (first parameter) ‘day’. For example

##### Oracle[¶](#id182)

```
SELECT AsDate - AsDateTwo FROM TIMES;
```

##### Result[¶](#id183)

<!-- prettier-ignore -->
|ASDATE-ASDATETWO|
|---|
|1|

##### Snowflake[¶](#id184)

```
SELECT AsDate - AsDateTwo FROM
TIMES;
```

##### Result[¶](#id185)

<!-- prettier-ignore -->
|DATEDIFF(DAY, ASDATETWO, ASDATE)|
|---|
|1|

#### Date - Interval day[¶](#id186)

This is the current transformation for the subtraction operation between a date type and a number.
For example

##### Oracle[¶](#id187)

```
SELECT AsDate - 1 FROM TIMES;

SELECT AsDate + -1 FROM TIMES;
```

##### Result[¶](#id188)

<!-- prettier-ignore -->
|ASDATE-1|
|---|
|2021-11-05 00:00:00.000|

<!-- prettier-ignore -->
|ASDATE+-1|
|---|
|2021-11-05 00:00:00.000|

##### Snowflake[¶](#id189)

```
SELECT
!!!RESOLVE EWI!!! /*** SSC-EWI-OR0036 - TYPES RESOLUTION ISSUES, ARITHMETIC OPERATION '-' MAY NOT BEHAVE CORRECTLY BETWEEN unknown AND Number ***/!!!
 AsDate - 1 FROM
 TIMES;

SELECT
 !!!RESOLVE EWI!!! /*** SSC-EWI-OR0036 - TYPES RESOLUTION ISSUES, ARITHMETIC OPERATION '+' MAY NOT BEHAVE CORRECTLY BETWEEN unknown AND Number ***/!!! AsDate + -1 FROM
 TIMES;
```

##### Result[¶](#id190)

<!-- prettier-ignore -->
|ASDATE - INTERVAL ‘1 DAY’|
|---|
|2021-11-05|

<!-- prettier-ignore -->
|ASDATE + INTERVAL ‘-1 DAY’|
|---|
|2021-11-05|

#### Timestamp - Interval day[¶](#id191)

This is the current transformation for the addition operation between a timestamp type and a number.
For example

##### Oracle[¶](#id192)

```
SELECT AsTimestamp - 1 FROM TIMES;

SELECT AsTimestamp + -1 FROM TIMES;
```

##### Result[¶](#id193)

<!-- prettier-ignore -->
|ASTIMESTAMP-1|
|---|
|2021-11-04 11:00:00.000|

<!-- prettier-ignore -->
|ASTIMESTAMP+-1|
|---|
|2021-11-04 11:00:00.000|

##### Snowflake[¶](#id194)

```
SELECT
!!!RESOLVE EWI!!! /*** SSC-EWI-OR0036 - TYPES RESOLUTION ISSUES, ARITHMETIC OPERATION '-' MAY NOT BEHAVE CORRECTLY BETWEEN unknown AND Number ***/!!!
 AsTimestamp - 1 FROM
 TIMES;

SELECT
 !!!RESOLVE EWI!!! /*** SSC-EWI-OR0036 - TYPES RESOLUTION ISSUES, ARITHMETIC OPERATION '+' MAY NOT BEHAVE CORRECTLY BETWEEN unknown AND Number ***/!!! AsTimestamp + -1 FROM
 TIMES;
```

##### Result[¶](#id195)

<!-- prettier-ignore -->
|ASTIMESTAMP - INTERVAL ‘1 DAY’|
|---|
|2021-11-04 11:00:00.000|

<!-- prettier-ignore -->
|ASTIMESTAMP + INTERVAL ‘-1 DAY’|
|---|
|2021-11-04 11:00:00.000|

**Note:**

Note: In Oracle, both DATE and TIMESTAMP columns contain a time component, but Oracle uses the
format mask specified by the NLS_DATE_FORMAT parameter to decide how to implicitly convert the date
to a string, that is why when performing some operations between the TIMESTAMP and Intervals, the
result could be shown as DATE, hiding the time component, unless the NLS_DATE_FORMAT parameter is
changed.

More information about the NLS_DATE_FORMAT format can be found
[here](https://docs.oracle.com/en/database/oracle/oracle-database/21/refrn/NLS_DATE_FORMAT.html#GUID-FC23EEEE-AA9F-4B3C-8CBB-888C9C0CA27F).

#### TIMESTAMP_DIFF_UDF[¶](#timestamp-diff-udf)

The subtractions between timestamp types and dates with a timestamp and vice versa; are resolved by
inserting the TIMESTAMP_DIFF_UDF user-defined function, (implementation
[here](../../functions/custom_udfs.html#timestamp-diff-udf)). For example

##### Oracle[¶](#id196)

```
SELECT AsTimeStamp - AsTimeStampTwo FROM TIMES;

SELECT AsTimeStamp - AsDateTwo FROM TIMES;

SELECT AsDateTwo - AsTimeStamp FROM TIMES;
```

##### Result[¶](#id197)

<!-- prettier-ignore -->
|ASTIMESTAMP-ASTIMESTAMPTWO|
|---|
|+000000000 01:00:00.000000|

<!-- prettier-ignore -->
|ASTIMESTAMP-ASDATETWO|
|---|
|+000000000 11:00:00.000000|

<!-- prettier-ignore -->
|ASDATETWO-ASTIMESTAMP|
|---|
|-000000000 11:00:00.000000|

##### Snowflake[¶](#id198)

```
SELECT AsTimeStamp - AsTimeStampTwo FROM
TIMES;

SELECT AsTimeStamp - AsDateTwo FROM
TIMES;

SELECT AsDateTwo - AsTimeStamp FROM
TIMES;
```

##### Result[¶](#id199)

<!-- prettier-ignore -->
|PUBLIC.TIMESTAMP_DIFF_UDF( ASTIMESTAMP, ASTIMESTAMPTWO)|
|---|
|+000000000 01:00:00.00000000|

<!-- prettier-ignore -->
|PUBLIC.TIMESTAMP_DIFF_UDF( ASTIMESTAMP, ASDATETWO)|
|---|
|+000000000 11:00:00.00000000|

<!-- prettier-ignore -->
|PUBLIC.TIMESTAMP_DIFF_UDF( ASDATETWO, ASTIMESTAMP)|
|---|
|-000000000 -11:00:00.00000000|

#### DATEDIFF_UDF[¶](#datediff-udf)

For those cases where there is an addition operation between a date or timestamp type and an unknown
type, a user-defined function (UDF) is added. The UDF implementation can be found
[here](../../functions/custom_udfs.html#datediff-udf), but it could be edited to perform what is
required. The UDF is located in the UDFs folder. For example:

##### Oracle[¶](#id200)

```
SELECT ASDATE - (EXTRACT(DAY FROM ASDATE)) FROM TIMES;

SELECT ASTIMESTAMP - (EXTRACT(DAY FROM ASDATE)) FROM TIMES;
```

##### Result[¶](#id201)

<!-- prettier-ignore -->
|ASDATE-(EXTRACT(DAYFROMASDATE))|
|---|
|2021-10-31 00:00:00.000|

<!-- prettier-ignore -->
|ASTIMESTAMP-(EXTRACT(DAYFROMASDATE))|
|---|
|2021-10-30 11:00:00.000|

##### Snowflake[¶](#id202)

```
SELECT ASDATE - (EXTRACT(DAY FROM ASDATE)) FROM
TIMES;


SELECT ASTIMESTAMP - (EXTRACT(DAY FROM ASDATE)) FROM
TIMES;
```

##### Result[¶](#id203)

<!-- prettier-ignore -->
|PUBLIC.DATEDIFF_UDF( ASDATE, (EXTRACT(DAY FROM ASDATE)))|
|---|
|2021-10-31|

<!-- prettier-ignore -->
|PUBLIC.DATEDIFF_UDF( ASTIMESTAMP, (EXTRACT(DAY FROM ASDATE)))|
|---|
|2021-10-30 11:00:00.000|

### Common Cases[¶](#common-cases)

#### Warning: SSC-EWI-OR0036[¶](#warning-ssc-ewi-or0036)

This warning is used to indicate whether an addition or subtraction operation may not behave
correctly due to the operands data types. It means that maybe the result of the operation in
Snowflake is not functionally equivalent to Oracle. The addition and subtraction between a date or
numeric type and an unknown type are one of the most common cases. For example

##### Oracle[¶](#id204)

```
SELECT AsDate - (EXTRACT(DAY FROM ASDATE)) FROM TIMES;
```

##### Snowflake[¶](#id205)

```
SELECT AsDate - (EXTRACT(DAY FROM ASDATE)) FROM
TIMES;
```

This EWI is added in operations where the type of a column could not be resolved, if the column type
is INTERVAL and it is operated only with other intervals, EWI will be added but code will not be
commented out. The following example describes this behavior:

##### Oracle[¶](#id206)

```
SELECT INTERVAL '1' DAY + interval_column FROM UNKNOWN_TABLE;
```

##### Snowflake[¶](#id207)

```
SELECT
!!!RESOLVE EWI!!! /*** SSC-EWI-OR0036 - TYPES RESOLUTION ISSUES, ARITHMETIC OPERATION '+' MAY NOT BEHAVE CORRECTLY BETWEEN Unknown AND Interval ***/!!!
interval_column + INTERVAL '1 day' FROM
UNKNOWN_TABLE;
```

### Known Issues[¶](#id208)

#### 1. TIMESTAMP DIFF UDF improvement[¶](#timestamp-diff-udf-improvement)

The TIMESTAMP_DIFF_UDF must be improved to be able to specify the return type. It means adding a
third parameter where it is possible to specify the time part, for example, day, hour, month, etc.

##### 2. Built-in functions as operators[¶](#built-in-functions-as-operators)

There is currently no management for date operations between built-in functions that return date
types.

##### 3. Multiple operands[¶](#multiple-operands)

Currently, there is no management for date operation with more than two operands, it may work but
you may also find issues.

##### 4. Comparison operators[¶](#comparison-operators)

Currently, there is no management for date operations with comparison operators like greater than,
lower than, etc.

##### 5. Output format[¶](#output-format)

The result’s format of the arithmetic operations could be changed by using the next command
`ALTER SESSION SET DATE_OUTPUT_FORMAT = 'DESIRED-FORMAT';` in Snowflake.

##### 6. Issues in interval operations with seconds precision[¶](#issues-in-interval-operations-with-seconds-precision)

Some operations may differ in precision, specifically those that include intervals with seconds
precision, this is because Oracle rounds depending on the precision, Snowflake’s interval does not
support seconds with decimal places, in order to have the same result, it is necessary to change the
second decimal places by milliseconds in intervals considering the rounding that Oracle performs.
The following example shows this issue

##### Oracle[¶](#id209)

```
SELECT AsTimeStamp+INTERVAL '15.6789' SECOND(2,3) FROM times;

SELECT AsTimeStamp+INTERVAL '15.6783' SECOND(2,3) FROM times;
```

##### Result[¶](#id210)

<!-- prettier-ignore -->
|ASTIMESTAMP+INTERVAL’15.6789’SECOND(2,3)|
|---|
|2021-11-05 11:00:15.679|

<!-- prettier-ignore -->
|ASTIMESTAMP+INTERVAL’15.6783’SECOND(2,3)|
|---|
|2021-11-05 11:00:15.678|

##### Snowflake[¶](#id211)

```
SELECT
!!!RESOLVE EWI!!! /*** SSC-EWI-OR0036 - TYPES RESOLUTION ISSUES, ARITHMETIC OPERATION '+' MAY NOT BEHAVE CORRECTLY BETWEEN Unknown AND Interval ***/!!!
 AsTimeStamp + INTERVAL '15.6789 second'
FROM
 times;

SELECT
 !!!RESOLVE EWI!!! /*** SSC-EWI-OR0036 - TYPES RESOLUTION ISSUES, ARITHMETIC OPERATION '+' MAY NOT BEHAVE CORRECTLY BETWEEN Unknown AND Interval ***/!!! AsTimeStamp + INTERVAL '15.6783 second'
FROM
 times;
```

##### Result[¶](#id212)

<!-- prettier-ignore -->
|ASTIMESTAMP + INTERVAL ‘15.6789 SECOND’|
|---|
|2021-11-05 11:00:16.000|

<!-- prettier-ignore -->
|ASTIMESTAMP + INTERVAL ‘15.6783 SECOND’|
|---|
|2021-11-05 11:00:16.000|

<!-- prettier-ignore -->
|ASTIMESTAMP + INTERVAL ‘15 SECOND, 679 MILLISECOND’|
|---|
|2021-11-05 11:00:15.679|

<!-- prettier-ignore -->
|ASTIMESTAMP + INTERVAL ‘15 SECOND, 678 MILLISECOND’|
|---|
|2021-11-05 11:00:15.678|

### Related EWIs[¶](#id213)

1. [SSC-EWI-0108](../../../../general/technical-documentation/issues-and-troubleshooting/conversion-issues/generalEWI.html#ssc-ewi-0108):
   The following subquery matches at least one of the patterns considered invalid and may produce
   compilation errors.
2. [SSC-EWI-OR0036](../../../../general/technical-documentation/issues-and-troubleshooting/conversion-issues/oracleEWI.html#ssc-ewi-or0036):
   Types resolution issues, the arithmetic operation may not behave correctly between string and
   date.

## Interval UDFs vs Snowflake native interval operation[¶](#interval-udfs-vs-snowflake-native-interval-operation)

### Description[¶](#id214)

The following table shows a comparison between the
[DATEADD_UDF INTERVAL](../../functions/custom_udfs.html#dateadd-udf-interval) and
[DATEDIFF_UDF INTERVAL](../../functions/custom_udfs.html#datediff-udf-interval) vs the
[Snowflake native operation](https://docs.snowflake.com/en/sql-reference/data-types-datetime.html#interval-constants)
for interval arithmetic.

#### Necessary Code[¶](#necessary-code)

To run the queries of the comparative table it is necessary to run the following code:

```
CREATE OR REPLACE TABLE TIMES(
AsTimeStamp TIMESTAMP,
AsTimestampTwo TIMESTAMP,
AsDate DATE,
AsDateTwo DATE
);

INSERT INTO TIMES VALUES (
  TO_TIMESTAMP('05/11/21, 11:00 A.M.', 'dd/mm/yy, hh:mi A.M.'),
  TO_TIMESTAMP('05/11/21, 10:00 A.M.', 'dd/mm/yy, hh:mi A.M.'),
  TO_DATE('06/11/21', 'dd/mm/yy'),
  TO_DATE('05/11/21', 'dd/mm/yy'));

CREATE TABLE UNKNOWN_TABLE(
  Unknown timestamp
);

INSERT INTO UNKNOWN_TABLE VALUES (
  TO_TIMESTAMP('01/10/09, 12:00 P.M.', 'dd/mm/yy, hh:mi P.M.')
);
```

```
CREATE OR REPLACE TABLE TIMES (
  AsTimeStamp TIMESTAMP(6),
  AsTimestampTwo TIMESTAMP(6),
  AsDate TIMESTAMP /*** SSC-FDM-OR0042 - DATE TYPE COLUMN HAS A DIFFERENT BEHAVIOR IN SNOWFLAKE. ***/,
  AsDateTwo TIMESTAMP /*** SSC-FDM-OR0042 - DATE TYPE COLUMN HAS A DIFFERENT BEHAVIOR IN SNOWFLAKE. ***/
  )
  COMMENT = '{"origin":"sf_sc","name":"snowconvert","version":{"major":1, "minor":0},"attributes":{"component":"oracle"}}'
  ;

  INSERT INTO TIMES
  VALUES (
  TO_TIMESTAMP('05/11/21, 11:00 A.M.', 'dd/mm/yy, hh:mi A.M.'),
  TO_TIMESTAMP('05/11/21, 10:00 A.M.', 'dd/mm/yy, hh:mi A.M.'),
  TO_DATE('06/11/21', 'dd/mm/yy'),
  TO_DATE('05/11/21', 'dd/mm/yy'));

  CREATE OR REPLACE TABLE UNKNOWN_TABLE (
  Unknown TIMESTAMP(6)
  )
  COMMENT = '{"origin":"sf_sc","name":"snowconvert","version":{"major":1, "minor":0},"attributes":{"component":"oracle"}}'
  ;

  INSERT INTO UNKNOWN_TABLE
  VALUES (
  TO_TIMESTAMP('01/10/09, 12:00 P.M.', 'dd/mm/yy, hh:mi P.M.')
);
```

### Comparison Table[¶](#comparison-table)

#### Oracle[¶](#id215)

```
SELECT AsTimeStamp+INTERVAL '1-1' YEAR(2) TO MONTH FROM TIMES;
SELECT AsTimeStamp-INTERVAL '1-1' YEAR(2) TO MONTH FROM TIMES;
SELECT AsTimeStamp+INTERVAL '2-1' YEAR(4) TO MONTH FROM TIMES;
SELECT AsTimeStamp-INTERVAL '2-1' YEAR(4) TO MONTH FROM TIMES;
SELECT AsTimeStamp+INTERVAL '1' MONTH FROM TIMES;
SELECT AsTimeStamp-INTERVAL '1' MONTH FROM TIMES;
SELECT AsTimeStamp+INTERVAL '2' MONTH FROM TIMES;
SELECT AsTimeStamp-INTERVAL '2' MONTH FROM TIMES;
SELECT AsTimeStamp+INTERVAL '1 01:00:00.222' DAY TO SECOND(3) FROM TIMES;
SELECT AsTimeStamp-INTERVAL '1 01:00:00.222' DAY TO SECOND(3) FROM TIMES;
SELECT AsTimeStamp+INTERVAL '1 01:10' DAY TO MINUTE FROM TIMES;
SELECT AsTimeStamp-INTERVAL '1 01:10' DAY TO MINUTE FROM TIMES;
SELECT AsTimeStamp+INTERVAL '1 1' DAY TO HOUR FROM TIMES;
SELECT AsTimeStamp-INTERVAL '1 1' DAY TO HOUR FROM TIMES;
SELECT AsTimeStamp+INTERVAL '10' DAY FROM TIMES;
SELECT AsTimeStamp-INTERVAL '10' DAY FROM TIMES;
SELECT AsTimeStamp+INTERVAL '3:05' HOUR TO MINUTE FROM TIMES;
SELECT AsTimeStamp-INTERVAL '3:05' HOUR TO MINUTE FROM TIMES;
SELECT AsTimeStamp+INTERVAL '5' HOUR FROM TIMES;
SELECT AsTimeStamp-INTERVAL '5' HOUR FROM TIMES;
SELECT AsTimeStamp+INTERVAL '5:10' MINUTE TO SECOND FROM TIMES;
SELECT AsTimeStamp-INTERVAL '5:10' MINUTE TO SECOND FROM TIMES;
SELECT AsTimeStamp+INTERVAL '30' MINUTE FROM TIMES;
SELECT AsTimeStamp-INTERVAL '30' MINUTE FROM TIMES;
SELECT AsTimeStamp+INTERVAL '333' HOUR(3) FROM TIMES;
SELECT AsTimeStamp-INTERVAL '333' HOUR(3) FROM TIMES;
SELECT AsTimeStamp+INTERVAL '15.6789' SECOND(2,3) FROM TIMES;
SELECT AsTimeStamp-INTERVAL '15.6789' SECOND(2,3) FROM TIMES;
SELECT AsDate+INTERVAL '1-1' YEAR(2) TO MONTH FROM TIMES;
SELECT AsDate-INTERVAL '1-1' YEAR(2) TO MONTH FROM TIMES;
SELECT AsDate+INTERVAL '2-1' YEAR(4) TO MONTH FROM TIMES;
SELECT AsDate-INTERVAL '2-1' YEAR(4) TO MONTH FROM TIMES;
SELECT AsDate+INTERVAL '1' MONTH FROM TIMES;
SELECT AsDate-INTERVAL '1' MONTH FROM TIMES;
SELECT AsDate+INTERVAL '2' MONTH FROM TIMES;
SELECT AsDate-INTERVAL '2' MONTH FROM TIMES;
SELECT AsDate+INTERVAL '1 01:00:00.222' DAY TO SECOND(3) FROM TIMES;
SELECT AsDate-INTERVAL '1 01:00:00.222' DAY TO SECOND(3) FROM TIMES;
SELECT AsDate+INTERVAL '1 01:10' DAY TO MINUTE FROM TIMES;
SELECT AsDate-INTERVAL '1 01:10' DAY TO MINUTE FROM TIMES;
SELECT AsDate+INTERVAL '1 1' DAY TO HOUR FROM TIMES;
SELECT AsDate-INTERVAL '1 1' DAY TO HOUR FROM TIMES;
SELECT AsDate+INTERVAL '10' DAY FROM TIMES;
SELECT AsDate-INTERVAL '10' DAY FROM TIMES;
SELECT AsDate+INTERVAL '3:05' HOUR TO MINUTE FROM TIMES;
SELECT AsDate-INTERVAL '3:05' HOUR TO MINUTE FROM TIMES;
SELECT AsDate+INTERVAL '5' HOUR FROM TIMES;
SELECT AsDate-INTERVAL '5' HOUR FROM TIMES;
SELECT AsDate+INTERVAL '5:10' MINUTE TO SECOND FROM TIMES;
SELECT AsDate-INTERVAL '5:10' MINUTE TO SECOND FROM TIMES;
SELECT AsDate+INTERVAL '30' MINUTE FROM TIMES;
SELECT AsDate-INTERVAL '30' MINUTE FROM TIMES;
SELECT AsDate+INTERVAL '333' HOUR(3) FROM TIMES;
SELECT AsDate-INTERVAL '333' HOUR(3) FROM TIMES;
SELECT AsDate+INTERVAL '15.6789' SECOND(2,3) FROM TIMES;
SELECT AsDate-INTERVAL '15.6789' SECOND(2,3) FROM TIMES;
SELECT Unknown+INTERVAL '1-1' YEAR(2) TO MONTH FROM UNKNOWN_TABLE;
SELECT Unknown-INTERVAL '1-1' YEAR(2) TO MONTH FROM UNKNOWN_TABLE;
SELECT Unknown+INTERVAL '2-1' YEAR(4) TO MONTH FROM UNKNOWN_TABLE;
SELECT Unknown-INTERVAL '2-1' YEAR(4) TO MONTH FROM UNKNOWN_TABLE;
SELECT Unknown+INTERVAL '1' MONTH FROM UNKNOWN_TABLE;
SELECT Unknown-INTERVAL '1' MONTH FROM UNKNOWN_TABLE;
SELECT Unknown+INTERVAL '2' MONTH FROM UNKNOWN_TABLE;
SELECT Unknown-INTERVAL '2' MONTH FROM UNKNOWN_TABLE;
SELECT Unknown+INTERVAL '1 01:00:00.222' DAY TO SECOND(3) FROM UNKNOWN_TABLE;
SELECT Unknown-INTERVAL '1 01:00:00.222' DAY TO SECOND(3) FROM UNKNOWN_TABLE;
SELECT Unknown+INTERVAL '1 01:10' DAY TO MINUTE FROM UNKNOWN_TABLE;
SELECT Unknown-INTERVAL '1 01:10' DAY TO MINUTE FROM UNKNOWN_TABLE;
SELECT Unknown+INTERVAL '1 1' DAY TO HOUR FROM UNKNOWN_TABLE;
SELECT Unknown-INTERVAL '1 1' DAY TO HOUR FROM UNKNOWN_TABLE;
SELECT Unknown+INTERVAL '10' DAY FROM UNKNOWN_TABLE;
SELECT Unknown-INTERVAL '10' DAY FROM UNKNOWN_TABLE;
SELECT Unknown+INTERVAL '3:05' HOUR TO MINUTE FROM UNKNOWN_TABLE;
SELECT Unknown-INTERVAL '3:05' HOUR TO MINUTE FROM UNKNOWN_TABLE;
SELECT Unknown+INTERVAL '5' HOUR FROM UNKNOWN_TABLE;
SELECT Unknown-INTERVAL '5' HOUR FROM UNKNOWN_TABLE;
SELECT Unknown+INTERVAL '5:10' MINUTE TO SECOND FROM UNKNOWN_TABLE;
SELECT Unknown-INTERVAL '5:10' MINUTE TO SECOND FROM UNKNOWN_TABLE;
SELECT Unknown+INTERVAL '30' MINUTE FROM UNKNOWN_TABLE;
SELECT Unknown-INTERVAL '30' MINUTE FROM UNKNOWN_TABLE;
SELECT Unknown+INTERVAL '333' HOUR(3) FROM UNKNOWN_TABLE;
SELECT Unknown-INTERVAL '333' HOUR(3) FROM UNKNOWN_TABLE;
SELECT Unknown+INTERVAL '15.6789' SECOND(2,3) FROM UNKNOWN_TABLE;
SELECT Unknown-INTERVAL '15.6789' SECOND(2,3) FROM UNKNOWN_TABLE;
SELECT INTERVAL '1-1' YEAR(2) TO MONTH+ AsTimeStamp FROM TIMES;
SELECT INTERVAL '1-1' YEAR(2) TO MONTH+AsDate FROM TIMES;
SELECT INTERVAL '1-1' YEAR(2) TO MONTH+Unknown FROM UNKNOWN_TABLE;
SELECT INTERVAL '2-1' YEAR(4) TO MONTH+AsTimeStamp FROM TIMES;
SELECT INTERVAL '2-1' YEAR(4) TO MONTH+AsDate FROM TIMES;
SELECT INTERVAL '2-1' YEAR(4) TO MONTH+Unknown FROM UNKNOWN_TABLE;
SELECT INTERVAL '1' MONTH+AsTimeStamp FROM TIMES;
SELECT INTERVAL '1' MONTH+AsDate FROM TIMES;
SELECT INTERVAL '1' MONTH+Unknown FROM UNKNOWN_TABLE;
SELECT INTERVAL '2' MONTH+AsTimeStamp FROM TIMES;
SELECT INTERVAL '2' MONTH+AsDate FROM TIMES;
SELECT INTERVAL '2' MONTH+Unknown FROM UNKNOWN_TABLE;
SELECT INTERVAL '1 01:00:00.222' DAY TO SECOND(3)+AsTimeStamp FROM TIMES;
SELECT INTERVAL '1 01:00:00.222' DAY TO SECOND(3)+AsDate FROM TIMES;
SELECT INTERVAL '1 01:00:00.222' DAY TO SECOND(3)+Unknown FROM UNKNOWN_TABLE;
SELECT INTERVAL '1 01:10' DAY TO MINUTE+AsTimeStamp FROM TIMES;
SELECT INTERVAL '1 01:10' DAY TO MINUTE+AsDate FROM TIMES;
SELECT INTERVAL '1 01:10' DAY TO MINUTE+Unknown FROM UNKNOWN_TABLE;
SELECT INTERVAL '1 1' DAY TO HOUR+AsTimeStamp FROM TIMES;
SELECT INTERVAL '1 1' DAY TO HOUR+AsDate FROM TIMES;
SELECT INTERVAL '1 1' DAY TO HOUR+Unknown FROM UNKNOWN_TABLE;
SELECT INTERVAL '10' DAY+AsTimeStamp FROM TIMES;
SELECT INTERVAL '10' DAY+AsDate FROM TIMES;
SELECT INTERVAL '10' DAY+Unknown FROM UNKNOWN_TABLE;
SELECT INTERVAL '3:05' HOUR TO MINUTE+AsTimeStamp FROM TIMES;
SELECT INTERVAL '3:05' HOUR TO MINUTE+AsDate FROM TIMES;
SELECT INTERVAL '3:05' HOUR TO MINUTE+Unknown FROM UNKNOWN_TABLE;
SELECT INTERVAL '5' HOUR+AsTimeStamp FROM TIMES;
SELECT INTERVAL '5' HOUR+AsDate FROM TIMES;
SELECT INTERVAL '5' HOUR+Unknown FROM UNKNOWN_TABLE;
SELECT INTERVAL '5:10' MINUTE TO SECOND+AsTimeStamp FROM TIMES;
SELECT INTERVAL '5:10' MINUTE TO SECOND+AsDate FROM TIMES;
SELECT INTERVAL '5:10' MINUTE TO SECOND+Unknown FROM UNKNOWN_TABLE;
SELECT INTERVAL '30' MINUTE+AsTimeStamp FROM TIMES;
SELECT INTERVAL '30' MINUTE+AsDate FROM TIMES;
SELECT INTERVAL '30' MINUTE+Unknown FROM UNKNOWN_TABLE;
SELECT INTERVAL '333' HOUR(3)+AsTimeStamp FROM TIMES;
SELECT INTERVAL '333' HOUR(3)+AsDate FROM TIMES;
SELECT INTERVAL '333' HOUR(3)+Unknown FROM UNKNOWN_TABLE;
SELECT INTERVAL '15.6789' SECOND(2,3)+AsTimeStamp FROM TIMES;
SELECT INTERVAL '15.6789' SECOND(2,3)+AsDate FROM TIMES;
SELECT INTERVAL '15.6789' SECOND(2,3)+Unknown FROM UNKNOWN_TABLE;
```

#### Snowflake[¶](#id216)

```
SELECT AsTimeStamp + INTERVAL '1y, 1mm' FROM PUBLIC.TIMES;
SELECT AsTimeStamp - INTERVAL '1y, 1mm' FROM PUBLIC.TIMES;
SELECT AsTimeStamp + INTERVAL '2y, 1mm' FROM PUBLIC.TIMES;
SELECT AsTimeStamp - INTERVAL '2y, 1mm' FROM PUBLIC.TIMES;
SELECT AsTimeStamp + INTERVAL '1 month' FROM PUBLIC.TIMES;
SELECT AsTimeStamp - INTERVAL '1 month' FROM PUBLIC.TIMES;
SELECT AsTimeStamp + INTERVAL '2 month' FROM PUBLIC.TIMES;
SELECT AsTimeStamp - INTERVAL '2 month' FROM PUBLIC.TIMES;
SELECT AsTimeStamp + INTERVAL '1d, 01h, 00m, 00s, 222ms' FROM PUBLIC.TIMES;
SELECT AsTimeStamp - INTERVAL '1d, 01h, 00m, 00s, 222ms' FROM PUBLIC.TIMES;
SELECT AsTimeStamp + INTERVAL '1d, 01h, 10m' FROM PUBLIC.TIMES;
SELECT AsTimeStamp - INTERVAL '1d, 01h, 10m' FROM PUBLIC.TIMES;
SELECT AsTimeStamp + INTERVAL '1d, 1h' FROM PUBLIC.TIMES;
SELECT AsTimeStamp - INTERVAL '1d, 1h' FROM PUBLIC.TIMES;
SELECT AsTimeStamp + INTERVAL '10 day' FROM PUBLIC.TIMES;
SELECT AsTimeStamp - INTERVAL '10 day' FROM PUBLIC.TIMES;
SELECT AsTimeStamp + INTERVAL '3h, 05m' FROM PUBLIC.TIMES;
SELECT AsTimeStamp - INTERVAL '3h, 05m' FROM PUBLIC.TIMES;
SELECT AsTimeStamp + INTERVAL '5 hour' FROM PUBLIC.TIMES;
SELECT AsTimeStamp - INTERVAL '5 hour' FROM PUBLIC.TIMES;
SELECT AsTimeStamp + INTERVAL '5m, 10s' FROM PUBLIC.TIMES;
SELECT AsTimeStamp - INTERVAL '5m, 10s' FROM PUBLIC.TIMES;
SELECT AsTimeStamp + INTERVAL '30 minute' FROM PUBLIC.TIMES;
SELECT AsTimeStamp - INTERVAL '30 minute' FROM PUBLIC.TIMES;
SELECT AsTimeStamp + INTERVAL '333 hour' FROM PUBLIC.TIMES;
SELECT AsTimeStamp - INTERVAL '333 hour' FROM PUBLIC.TIMES;
SELECT AsTimeStamp + INTERVAL '15.6789 second' FROM PUBLIC.TIMES;
SELECT AsTimeStamp - INTERVAL '15.6789 second' FROM PUBLIC.TIMES;
SELECT AsDate + INTERVAL '1y, 1mm' FROM PUBLIC.TIMES;
SELECT AsDate - INTERVAL '1y, 1mm' FROM PUBLIC.TIMES;
SELECT AsDate + INTERVAL '2y, 1mm' FROM PUBLIC.TIMES;
SELECT AsDate - INTERVAL '2y, 1mm' FROM PUBLIC.TIMES;
SELECT AsDate + INTERVAL '1 month' FROM PUBLIC.TIMES;
SELECT AsDate - INTERVAL '1 month' FROM PUBLIC.TIMES;
SELECT AsDate + INTERVAL '2 month' FROM PUBLIC.TIMES;
SELECT AsDate - INTERVAL '2 month' FROM PUBLIC.TIMES;
SELECT AsDate + INTERVAL '1d, 01h, 00m, 00s, 222ms' FROM PUBLIC.TIMES;
SELECT AsDate - INTERVAL '1d, 01h, 00m, 00s, 222ms' FROM PUBLIC.TIMES;
SELECT AsDate + INTERVAL '1d, 01h, 10m' FROM PUBLIC.TIMES;
SELECT AsDate - INTERVAL '1d, 01h, 10m' FROM PUBLIC.TIMES;
SELECT AsDate + INTERVAL '1d, 1h' FROM PUBLIC.TIMES;
SELECT AsDate - INTERVAL '1d, 1h' FROM PUBLIC.TIMES;
SELECT AsDate + INTERVAL '10 day' FROM PUBLIC.TIMES;
SELECT AsDate - INTERVAL '10 day' FROM PUBLIC.TIMES;
SELECT AsDate + INTERVAL '3h, 05m' FROM PUBLIC.TIMES;
SELECT AsDate - INTERVAL '3h, 05m' FROM PUBLIC.TIMES;
SELECT AsDate + INTERVAL '5 hour' FROM PUBLIC.TIMES;
SELECT AsDate - INTERVAL '5 hour' FROM PUBLIC.TIMES;
SELECT AsDate + INTERVAL '5m, 10s' FROM PUBLIC.TIMES;
SELECT AsDate - INTERVAL '5m, 10s' FROM PUBLIC.TIMES;
SELECT AsDate + INTERVAL '30 minute' FROM PUBLIC.TIMES;
SELECT AsDate - INTERVAL '30 minute' FROM PUBLIC.TIMES;
SELECT AsDate + INTERVAL '333 hour' FROM PUBLIC.TIMES;
SELECT AsDate - INTERVAL '333 hour' FROM PUBLIC.TIMES;
SELECT AsDate + INTERVAL '15.6789 second' FROM PUBLIC.TIMES;
SELECT AsDate - INTERVAL '15.6789 second' FROM PUBLIC.TIMES;
SELECT Unknown + INTERVAL '1y, 1mm' FROM PUBLIC.UNKNOWN_TABLE;
SELECT Unknown - INTERVAL '1y, 1mm' FROM PUBLIC.UNKNOWN_TABLE;
SELECT Unknown + INTERVAL '2y, 1mm' FROM PUBLIC.UNKNOWN_TABLE;
SELECT Unknown - INTERVAL '2y, 1mm' FROM PUBLIC.UNKNOWN_TABLE;
SELECT Unknown + INTERVAL '1 month' FROM PUBLIC.UNKNOWN_TABLE;
SELECT Unknown - INTERVAL '1 month' FROM PUBLIC.UNKNOWN_TABLE;
SELECT Unknown + INTERVAL '2 month' FROM PUBLIC.UNKNOWN_TABLE;
SELECT Unknown - INTERVAL '2 month' FROM PUBLIC.UNKNOWN_TABLE;
SELECT Unknown + INTERVAL '1d, 01h, 00m, 00s, 222ms' FROM PUBLIC.UNKNOWN_TABLE;
SELECT Unknown - INTERVAL '1d, 01h, 00m, 00s, 222ms' FROM PUBLIC.UNKNOWN_TABLE;
SELECT Unknown + INTERVAL '1d, 01h, 10m' FROM PUBLIC.UNKNOWN_TABLE;
SELECT Unknown - INTERVAL '1d, 01h, 10m' FROM PUBLIC.UNKNOWN_TABLE;
SELECT Unknown + INTERVAL '1d, 1h' FROM PUBLIC.UNKNOWN_TABLE;
SELECT Unknown - INTERVAL '1d, 1h' FROM PUBLIC.UNKNOWN_TABLE;
SELECT Unknown + INTERVAL '10 day' FROM PUBLIC.UNKNOWN_TABLE;
SELECT Unknown - INTERVAL '10 day' FROM PUBLIC.UNKNOWN_TABLE;
SELECT Unknown + INTERVAL '3h, 05m' FROM PUBLIC.UNKNOWN_TABLE;
SELECT Unknown - INTERVAL '3h, 05m' FROM PUBLIC.UNKNOWN_TABLE;
SELECT Unknown + INTERVAL '5 hour' FROM PUBLIC.UNKNOWN_TABLE;
SELECT Unknown - INTERVAL '5 hour' FROM PUBLIC.UNKNOWN_TABLE;
SELECT Unknown + INTERVAL '5m, 10s' FROM PUBLIC.UNKNOWN_TABLE;
SELECT Unknown - INTERVAL '5m, 10s' FROM PUBLIC.UNKNOWN_TABLE;
SELECT Unknown + INTERVAL '30 minute' FROM PUBLIC.UNKNOWN_TABLE;
SELECT Unknown - INTERVAL '30 minute' FROM PUBLIC.UNKNOWN_TABLE;
SELECT Unknown + INTERVAL '333 hour' FROM PUBLIC.UNKNOWN_TABLE;
SELECT Unknown - INTERVAL '333 hour' FROM PUBLIC.UNKNOWN_TABLE;
SELECT Unknown + INTERVAL '15.6789 second' FROM PUBLIC.UNKNOWN_TABLE;
SELECT Unknown - INTERVAL '15.6789 second' FROM PUBLIC.UNKNOWN_TABLE;
```

#### Snowflake UDF[¶](#snowflake-udf)

```
SELECT DATEADD_UDF(AsTimeStamp,'INTERVAL ''1-1'' YEAR(2) TO MONTH') FROM PUBLIC.TIMES;
SELECT DATEDIFF_UDF(AsTimeStamp,'INTERVAL ''1-1'' YEAR(2) TO MONTH') FROM PUBLIC.TIMES;
SELECT DATEADD_UDF(AsTimeStamp,'INTERVAL ''2-1'' YEAR(4) TO MONTH') FROM PUBLIC.TIMES;
SELECT DATEDIFF_UDF(AsTimeStamp,'INTERVAL ''2-1'' YEAR(4) TO MONTH') FROM PUBLIC.TIMES;
SELECT DATEADD_UDF(AsTimeStamp,'INTERVAL ''1'' MONTH') FROM PUBLIC.TIMES;
SELECT DATEDIFF_UDF(AsTimeStamp,'INTERVAL ''1'' MONTH') FROM PUBLIC.TIMES;
SELECT DATEADD_UDF(AsTimeStamp,'INTERVAL ''2'' MONTH') FROM PUBLIC.TIMES;
SELECT DATEDIFF_UDF(AsTimeStamp,'INTERVAL ''2'' MONTH') FROM PUBLIC.TIMES;
SELECT DATEADD_UDF(AsTimeStamp,'INTERVAL ''1 01:00:00.222'' DAY TO SECOND(3)') FROM PUBLIC.TIMES;
SELECT DATEDIFF_UDF(AsTimeStamp,'INTERVAL ''1 01:00:00.222'' DAY TO SECOND(3)') FROM PUBLIC.TIMES;
SELECT DATEADD_UDF(AsTimeStamp,'INTERVAL ''1 01:10'' DAY TO MINUTE') FROM PUBLIC.TIMES;
SELECT DATEDIFF_UDF(AsTimeStamp,'INTERVAL ''1 01:10'' DAY TO MINUTE') FROM PUBLIC.TIMES;
SELECT DATEADD_UDF(AsTimeStamp,'INTERVAL ''1 1'' DAY TO HOUR') FROM PUBLIC.TIMES;
SELECT DATEDIFF_UDF(AsTimeStamp,'INTERVAL ''1 1'' DAY TO HOUR') FROM PUBLIC.TIMES;
SELECT DATEADD_UDF(AsTimeStamp,'INTERVAL ''10'' DAY') FROM PUBLIC.TIMES;
SELECT DATEDIFF_UDF(AsTimeStamp,'INTERVAL ''10'' DAY') FROM PUBLIC.TIMES;
SELECT DATEADD_UDF(AsTimeStamp,'INTERVAL ''3:05'' HOUR TO MINUTE') FROM PUBLIC.TIMES;
SELECT DATEDIFF_UDF(AsTimeStamp,'INTERVAL ''3:05'' HOUR TO MINUTE') FROM PUBLIC.TIMES;
SELECT DATEADD_UDF(AsTimeStamp,'INTERVAL ''5'' HOUR') FROM PUBLIC.TIMES;
SELECT DATEDIFF_UDF(AsTimeStamp,'INTERVAL ''5'' HOUR') FROM PUBLIC.TIMES;
SELECT DATEADD_UDF(AsTimeStamp,'INTERVAL ''5:10'' MINUTE TO SECOND') FROM PUBLIC.TIMES;
SELECT DATEDIFF_UDF(AsTimeStamp,'INTERVAL ''5:10'' MINUTE TO SECOND') FROM PUBLIC.TIMES;
SELECT DATEADD_UDF(AsTimeStamp,'INTERVAL ''30'' MINUTE') FROM PUBLIC.TIMES;
SELECT DATEDIFF_UDF(AsTimeStamp,'INTERVAL ''30'' MINUTE') FROM PUBLIC.TIMES;
SELECT DATEADD_UDF(AsTimeStamp,'INTERVAL ''333'' HOUR(3)') FROM PUBLIC.TIMES;
SELECT DATEDIFF_UDF(AsTimeStamp,'INTERVAL ''333'' HOUR(3)') FROM PUBLIC.TIMES;
SELECT DATEADD_UDF(AsTimeStamp,'INTERVAL ''15.6789'' SECOND(2,3)') FROM PUBLIC.TIMES;
SELECT DATEDIFF_UDF(AsTimeStamp,'INTERVAL ''15.6789'' SECOND(2,3)') FROM PUBLIC.TIMES;
SELECT DATEADD_UDF(AsDate,'INTERVAL ''1-1'' YEAR(2) TO MONTH') FROM PUBLIC.TIMES;
SELECT DATEDIFF_UDF(AsDate,'INTERVAL ''1-1'' YEAR(2) TO MONTH') FROM PUBLIC.TIMES;
SELECT DATEADD_UDF(AsDate,'INTERVAL ''2-1'' YEAR(4) TO MONTH') FROM PUBLIC.TIMES;
SELECT DATEDIFF_UDF(AsDate,'INTERVAL ''2-1'' YEAR(4) TO MONTH') FROM PUBLIC.TIMES;
SELECT DATEADD_UDF(AsDate,'INTERVAL ''1'' MONTH') FROM PUBLIC.TIMES;
SELECT DATEDIFF_UDF(AsDate,'INTERVAL ''1'' MONTH') FROM PUBLIC.TIMES;
SELECT DATEADD_UDF(AsDate,'INTERVAL ''2'' MONTH') FROM PUBLIC.TIMES;
SELECT DATEDIFF_UDF(AsDate,'INTERVAL ''2'' MONTH') FROM PUBLIC.TIMES;
SELECT DATEADD_UDF(AsDate,'INTERVAL ''1 01:00:00.222'' DAY TO SECOND(3)') FROM PUBLIC.TIMES;
SELECT DATEDIFF_UDF(AsDate,'INTERVAL ''1 01:00:00.222'' DAY TO SECOND(3)') FROM PUBLIC.TIMES;
SELECT DATEADD_UDF(AsDate,'INTERVAL ''1 01:10'' DAY TO MINUTE') FROM PUBLIC.TIMES;
SELECT DATEDIFF_UDF(AsDate,'INTERVAL ''1 01:10'' DAY TO MINUTE') FROM PUBLIC.TIMES;
SELECT DATEADD_UDF(AsDate,'INTERVAL ''1 1'' DAY TO HOUR') FROM PUBLIC.TIMES;
SELECT DATEDIFF_UDF(AsDate,'INTERVAL ''1 1'' DAY TO HOUR') FROM PUBLIC.TIMES;
SELECT DATEADD_UDF(AsDate,'INTERVAL ''10'' DAY') FROM PUBLIC.TIMES;
SELECT DATEDIFF_UDF(AsDate,'INTERVAL ''10'' DAY') FROM PUBLIC.TIMES;
SELECT DATEADD_UDF(AsDate,'INTERVAL ''3:05'' HOUR TO MINUTE') FROM PUBLIC.TIMES;
SELECT DATEDIFF_UDF(AsDate,'INTERVAL ''3:05'' HOUR TO MINUTE') FROM PUBLIC.TIMES;
SELECT DATEADD_UDF(AsDate,'INTERVAL ''5'' HOUR') FROM PUBLIC.TIMES;
SELECT DATEDIFF_UDF(AsDate,'INTERVAL ''5'' HOUR') FROM PUBLIC.TIMES;
SELECT DATEADD_UDF(AsDate,'INTERVAL ''5:10'' MINUTE TO SECOND') FROM PUBLIC.TIMES;
SELECT DATEDIFF_UDF(AsDate,'INTERVAL ''5:10'' MINUTE TO SECOND') FROM PUBLIC.TIMES;
SELECT DATEADD_UDF(AsDate,'INTERVAL ''30'' MINUTE') FROM PUBLIC.TIMES;
SELECT DATEDIFF_UDF(AsDate,'INTERVAL ''30'' MINUTE') FROM PUBLIC.TIMES;
SELECT DATEADD_UDF(AsDate,'INTERVAL ''333'' HOUR(3)') FROM PUBLIC.TIMES;
SELECT DATEDIFF_UDF(AsDate,'INTERVAL ''333'' HOUR(3)') FROM PUBLIC.TIMES;
SELECT DATEADD_UDF(AsDate,'INTERVAL ''15.6789'' SECOND(2,3)') FROM PUBLIC.TIMES;
SELECT DATEDIFF_UDF(AsDate,'INTERVAL ''15.6789'' SECOND(2,3)') FROM PUBLIC.TIMES;
SELECT DATEADD_UDF(UnKnown,'INTERVAL ''1-1'' YEAR(2) TO MONTH') FROM PUBLIC.UNKNOWN_TABLE;
SELECT DATEDIFF_UDF(UnKnown,'INTERVAL ''1-1'' YEAR(2) TO MONTH') FROM PUBLIC.UNKNOWN_TABLE;
SELECT DATEADD_UDF(UnKnown,'INTERVAL ''2-1'' YEAR(4) TO MONTH') FROM PUBLIC.UNKNOWN_TABLE;
SELECT DATEDIFF_UDF(UnKnown,'INTERVAL ''2-1'' YEAR(4) TO MONTH') FROM PUBLIC.UNKNOWN_TABLE;
SELECT DATEADD_UDF(UnKnown,'INTERVAL ''1'' MONTH') FROM PUBLIC.UNKNOWN_TABLE;
SELECT DATEDIFF_UDF(UnKnown,'INTERVAL ''1'' MONTH') FROM PUBLIC.UNKNOWN_TABLE;
SELECT DATEADD_UDF(UnKnown,'INTERVAL ''2'' MONTH') FROM PUBLIC.UNKNOWN_TABLE;
SELECT DATEDIFF_UDF(UnKnown,'INTERVAL ''2'' MONTH') FROM PUBLIC.UNKNOWN_TABLE;
SELECT DATEADD_UDF(UnKnown,'INTERVAL ''1 01:00:00.222'' DAY TO SECOND(3)') FROM PUBLIC.UNKNOWN_TABLE;
SELECT DATEDIFF_UDF(UnKnown,'INTERVAL ''1 01:00:00.222'' DAY TO SECOND(3)') FROM PUBLIC.UNKNOWN_TABLE;
SELECT DATEADD_UDF(UnKnown,'INTERVAL ''1 01:10'' DAY TO MINUTE') FROM PUBLIC.UNKNOWN_TABLE;
SELECT DATEDIFF_UDF(UnKnown,'INTERVAL ''1 01:10'' DAY TO MINUTE') FROM PUBLIC.UNKNOWN_TABLE;
SELECT DATEADD_UDF(UnKnown,'INTERVAL ''1 1'' DAY TO HOUR') FROM PUBLIC.UNKNOWN_TABLE;
SELECT DATEDIFF_UDF(UnKnown,'INTERVAL ''1 1'' DAY TO HOUR') FROM PUBLIC.UNKNOWN_TABLE;
SELECT DATEADD_UDF(UnKnown,'INTERVAL ''10'' DAY') FROM PUBLIC.UNKNOWN_TABLE;
SELECT DATEDIFF_UDF(UnKnown,'INTERVAL ''10'' DAY') FROM PUBLIC.UNKNOWN_TABLE;
SELECT DATEADD_UDF(UnKnown,'INTERVAL ''3:05'' HOUR TO MINUTE') FROM PUBLIC.UNKNOWN_TABLE;
SELECT DATEDIFF_UDF(UnKnown,'INTERVAL ''3:05'' HOUR TO MINUTE') FROM PUBLIC.UNKNOWN_TABLE;
SELECT DATEADD_UDF(UnKnown,'INTERVAL ''5'' HOUR') FROM PUBLIC.UNKNOWN_TABLE;
SELECT DATEDIFF_UDF(UnKnown,'INTERVAL ''5'' HOUR') FROM PUBLIC.UNKNOWN_TABLE;
SELECT DATEADD_UDF(UnKnown,'INTERVAL ''5:10'' MINUTE TO SECOND') FROM PUBLIC.UNKNOWN_TABLE;
SELECT DATEDIFF_UDF(UnKnown,'INTERVAL ''5:10'' MINUTE TO SECOND') FROM PUBLIC.UNKNOWN_TABLE;
SELECT DATEADD_UDF(UnKnown,'INTERVAL ''30'' MINUTE') FROM PUBLIC.UNKNOWN_TABLE;
SELECT DATEDIFF_UDF(UnKnown,'INTERVAL ''30'' MINUTE') FROM PUBLIC.UNKNOWN_TABLE;
SELECT DATEADD_UDF(UnKnown,'INTERVAL ''333'' HOUR(3)') FROM PUBLIC.UNKNOWN_TABLE;
SELECT DATEDIFF_UDF(UnKnown,'INTERVAL ''333'' HOUR(3)') FROM PUBLIC.UNKNOWN_TABLE;
SELECT DATEADD_UDF(UnKnown,'INTERVAL ''15.6789'' SECOND(2,3)') FROM PUBLIC.UNKNOWN_TABLE;
SELECT DATEDIFF_UDF(UnKnown,'INTERVAL ''15.6789'' SECOND(2,3)') FROM PUBLIC.UNKNOWN_TABLE;
```

#### Results[¶](#results)

<!-- prettier-ignore -->
|Oracle|Snowflake Operation|UDF|
|---|---|---|
|2022-12-05 11:00:00.000|2022-12-05 11:00:00.000|2022-12-05 11:00:00.000|
|2020-10-05 11:00:00.000|2020-10-05 11:00:00.000|2020-10-05 11:00:00.000|
|2023-12-05 11:00:00.000|2023-12-05 11:00:00.000|2023-12-05 11:00:00.000|
|2019-10-05 11:00:00.000|2019-10-05 11:00:00.000|2019-10-05 11:00:00.000|
|2021-12-05 11:00:00.000|2021-12-05 11:00:00.000|2021-12-05 11:00:00.000|
|2021-10-05 11:00:00.000|2021-10-05 11:00:00.000|2021-10-05 11:00:00.000|
|2022-01-05 11:00:00.000|2022-01-05 11:00:00.000|2022-01-05 11:00:00.000|
|2021-09-05 11:00:00.000|2021-09-05 11:00:00.000|2021-09-05 11:00:00.000|
|2021-11-06 12:00:00.222|2021-11-06 12:00:00.222|2021-11-06 12:00:00.222|
|2021-11-04 09:59:59.778|2021-11-04 09:59:59.778|2021-11-04 09:59:59.778|
|2021-11-06 12:10:00.000|2021-11-06 12:10:00.000|2021-11-06 12:10:00.000|
|2021-11-04 09:50:00.000|2021-11-04 09:50:00.000|2021-11-04 09:50:00.000|
|2021-11-06 12:00:00.000|2021-11-06 12:00:00.000|2021-11-06 12:00:00.000|
|2021-11-04 10:00:00.000|2021-11-04 10:00:00.000|2021-11-04 10:00:00.000|
|2021-11-15 11:00:00.000|2021-11-15 11:00:00.000|2021-11-15 11:00:00.000|
|2021-10-26 11:00:00.000|2021-10-26 11:00:00.000|2021-10-26 11:00:00.000|
|2021-11-05 14:05:00.000|2021-11-05 14:05:00.000|2021-11-05 14:05:00.000|
|2021-11-05 07:55:00.000|2021-11-05 07:55:00.000|2021-11-05 07:55:00.000|
|2021-11-05 16:00:00.000|2021-11-05 16:00:00.000|2021-11-05 16:00:00.000|
|2021-11-05 06:00:00.000|2021-11-05 06:00:00.000|2021-11-05 06:00:00.000|
|2021-11-05 11:05:10.000|2021-11-05 11:05:10.000|2021-11-05 11:05:10.000|
|2021-11-05 10:54:50.000|2021-11-05 10:54:50.000|2021-11-05 10:54:50.000|
|2021-11-05 11:30:00.000|2021-11-05 11:30:00.000|2021-11-05 11:30:00.000|
|2021-11-05 10:30:00.000|2021-11-05 10:30:00.000|2021-11-05 10:30:00.000|
|2021-11-19 08:00:00.000|2021-11-19 08:00:00.000|2021-11-19 08:00:00.000|
|2021-10-22 14:00:00.000|2021-10-22 14:00:00.000|2021-10-22 14:00:00.000|
|2021-11-05 11:00:15.679|2021-11-05 11:00:16.000|2021-11-05 11:00:15.678|
|2021-11-05 10:59:44.321|2021-11-05 10:59:44.000|2021-11-05 11:00:15.678|
|2022-12-06 00:00:00.000|2022-12-06|2022-12-06|
|2020-10-06 00:00:00.000|2020-10-06|2020-10-06|
|2023-12-06 00:00:00.000|2023-12-06|2023-12-06|
|2019-10-06 00:00:00.000|2019-10-06|2019-10-06|
|2021-12-06 00:00:00.000|2021-12-06|2021-12-06|
|2021-12-06 00:00:00.000|2021-10-06|2021-10-06|
|2022-01-06 00:00:00.000|2022-01-06|2022-01-06|
|2021-09-06 00:00:00.000|2021-09-06|2021-09-06|
|2021-11-07 01:00:00.000|2021-11-07 01:00:00.222|2021-11-07|
|2021-11-04 22:59:59.000|2021-11-04 22:59:59.778|2021-11-04|
|2021-11-07 01:10:00.000|2021-11-07 01:10:00.000|2021-11-07|
|2021-11-04 22:50:00.000|2021-11-04 22:50:00.000|2021-11-04|
|2021-11-07 01:00:00.000|2021-11-07 01:00:00.000|2021-11-07|
|2021-11-04 23:00:00.000|2021-11-04 23:00:00.000|2021-11-04|
|2021-11-16 00:00:00.000|2021-11-16|2021-11-16|
|2021-10-27 00:00:00.000|2021-10-27|2021-10-27|
|2021-11-06 03:05:00.000|2021-11-06 03:05:00.000|2021-11-06|
|2021-11-05 20:55:00.000|2021-11-05 20:55:00.000|2021-11-05|
|2021-11-06 05:00:00.000|2021-11-06 05:00:00.000|2021-11-06|
|2021-11-05 19:00:00.000|2021-11-05 19:00:00.000|2021-11-05|
|2021-11-06 00:05:10.000|2021-11-06 00:05:10.000|2021-11-06|
|2021-11-05 23:54:50.000|2021-11-05 23:54:50.000|2021-11-05|
|2021-11-06 00:30:00.000|2021-11-06 00:30:00.000|2021-11-06|
|2021-11-05 23:30:00.000|2021-11-05 23:30:00.000|2021-11-05|
|2021-11-19 21:00:00.000|2021-11-19 21:00:00.000|2021-11-19|
|2021-10-23 03:00:00.000|2021-10-23 03:00:00.000|2021-10-23|
|2021-11-06 00:00:15.000|2021-11-06 00:00:16.000|2021-11-06|
|2021-11-05 23:59:44.000|2021-11-05 23:59:44.000|2021-11-05|
|2010-11-01 12:00:00.000|2010-11-01 12:00:00.000|2010-11-01 12:00:00.000|
|2008-09-01 12:00:00.000|2008-09-01 12:00:00.000|2008-09-01 12:00:00.000|
|2011-11-01 12:00:00.000|2011-11-01 12:00:00.000|2011-11-01 12:00:00.000|
|2007-09-01 12:00:00.000|2007-09-01 12:00:00.000|2007-09-01 12:00:00.000|
|2009-11-01 12:00:00.000|2009-11-01 12:00:00.000|2009-11-01 12:00:00.000|
|2009-09-01 12:00:00.000|2009-09-01 12:00:00.000|2009-09-01 12:00:00.000|
|2009-12-01 12:00:00.000|2009-12-01 12:00:00.000|2009-12-01 12:00:00.000|
|2009-08-01 12:00:00.000|2009-08-01 12:00:00.000|2009-08-01 12:00:00.000|
|2009-10-02 13:00:00.222|2009-10-02 13:00:00.222|2009-10-02 13:00:00.222|
|2009-09-30 10:59:59.778|2009-09-30 10:59:59.778|2009-09-30 10:59:59.778|
|2009-10-02 13:10:00.000|2009-10-02 13:10:00.000|2009-10-02 13:10:00.000|
|2009-09-30 10:50:00.000|2009-09-30 10:50:00.000|2009-09-30 10:50:00.000|
|2009-10-02 13:00:00.000|2009-10-02 13:00:00.000|2009-10-02 13:00:00.000|
|2009-09-30 11:00:00.000|2009-09-30 11:00:00.000|2009-09-30 11:00:00.000|
|2009-10-11 12:00:00.000|2009-10-11 12:00:00.000|2009-10-11 12:00:00.000|
|2009-09-21 12:00:00.000|2009-09-21 12:00:00.000|2009-09-21 12:00:00.000|
|2009-10-01 15:05:00.000|2009-10-01 15:05:00.000|2009-10-01 15:05:00.000|
|2009-10-01 08:55:00.000|2009-10-01 08:55:00.000|2009-10-01 08:55:00.000|
|2009-10-01 17:00:00.000|2009-10-01 17:00:00.000|2009-10-01 17:00:00.000|
|2009-10-01 07:00:00.000|2009-10-01 07:00:00.000|2009-10-01 07:00:00.000|
|2009-10-01 12:05:10.000|2009-10-01 12:05:10.000|2009-10-01 12:05:10.000|
|2009-10-01 11:54:50.000|2009-10-01 11:54:50.000|2009-10-01 11:54:50.000|
|2009-10-01 12:30:00.000|2009-10-01 12:30:00.000|2009-10-01 12:30:00.000|
|2009-10-01 11:30:00.000|2009-10-01 11:30:00.000|2009-10-01 11:30:00.000|
|2009-10-15 09:00:00.000|2009-10-15 09:00:00.000|2009-10-15 09:00:00.000|
|2009-09-17 15:00:00.000|2009-09-17 15:00:00.000|2009-09-17 15:00:00.000|
|2009-10-01 12:00:15.679|2009-10-01 12:00:16.000|2009-10-01 12:00:15.678|
|2009-10-01 11:59:44.321|2009-10-01 11:59:44.000|2009-10-01 11:59:44.321|

### Known Issues[¶](#id217)

No issues were found.

### Related EWIs[¶](#id218)

1. [SSC-FDM-OR0042](../../../../general/technical-documentation/issues-and-troubleshooting/functional-difference/oracleFDM.html#ssc-fdm-or0042):
   Date Type Transformed To Timestamp Has A Different Behavior

## PL SQL Data Types[¶](#pl-sql-data-types)

## BINARY_INTEGER Data Type[¶](#binary-integer-data-type)

This data type is identical to the [PLS_INTEGER](#pls-integer-data-type) data type.

## PLS_INTEGER Data Type[¶](#pls-integer-data-type)

### Description[¶](#id219)

> The `PLS_INTEGER` data type stores signed integers in the range -2,147,483,648 through
> 2,147,483,647, represented in 32 bits.
> ([Oracle Language Reference PLS_INTEGER Data Type](https://docs.oracle.com/en/database/oracle/oracle-database/21/lnpls/plsql-data-types.html#GUID-9517B7AC-9CEA-4C36-A454-52588BEEBE8F))

The `PLS_INTEGER` datatype is transformed to `NUMBER`. This transformation also applies for each
`PLS_INTEGER` subtype:

- `NATURAL`
- `NATURALN`
- `POSITIVE`
- `POSITIVEN`
- `SIGNTYPE`
- `SIMPLE_INTEGER`

Warning

Some of these subtypes are currently not recognized by SnowConvert AI so they are converted to
`VARIANT` and considered user-defined types. There is already a work item to fix the issue.

### Sample Source Patterns[¶](#id220)

Please, consider the following table and its inserts for the examples below:

#### Code[¶](#code)

```
CREATE TABLE PLS_INTEGER_TABLE(
	COL NUMBER
);
```

#### PLS_INTEGER usage in procedural blocks[¶](#pls-integer-usage-in-procedural-blocks)

##### Oracle[¶](#id221)

```
CREATE OR REPLACE PROCEDURE PLS_INTEGER_EXAMPLE
IS
-- PLS_INTEGER AND BINARY INTEGER ALIASES
PLS_INTEGER_VAR PLS_INTEGER;
BINARY_INTEGER_VAR BINARY_INTEGER;

NUMBER_VAR NUMBER;
BEGIN
	NUMBER_VAR := 2;

	-- maximum possible value
	PLS_INTEGER_VAR := 2147483647;

	-- implicit cast to number
	INSERT INTO PLS_INTEGER_TABLE (COL) VALUES (PLS_INTEGER_VAR);
	PLS_INTEGER_VAR := 2147483647;

	-- operations with other numeric expressions
	INSERT INTO PLS_INTEGER_TABLE (COL) VALUES (PLS_INTEGER_VAR + 1);
	INSERT INTO PLS_INTEGER_TABLE (COL) VALUES (PLS_INTEGER_VAR + NUMBER_VAR);
END;

CALL PLS_INTEGER_EXAMPLE();
SELECT * FROM PLS_INTEGER_TABLE;
```

##### Result[¶](#id222)

<!-- prettier-ignore -->
|COL|
|---|
|2147483647|
|2147483648|
|2147483649|

##### Snowflake[¶](#id223)

```
CREATE OR REPLACE PROCEDURE PLS_INTEGER_EXAMPLE ()
RETURNS VARCHAR
LANGUAGE SQL
COMMENT = '{"origin":"sf_sc","name":"snowconvert","version":{"major":1, "minor":0},{"attributes":{"component":"oracle"}}'
EXECUTE AS CALLER
AS
$$
	DECLARE
		-- PLS_INTEGER AND BINARY INTEGER ALIASES
		PLS_INTEGER_VAR NUMBER;
		BINARY_INTEGER_VAR NUMBER;

		NUMBER_VAR NUMBER(38, 18);
	BEGIN
		NUMBER_VAR := 2;
	-- maximum possible value
		PLS_INTEGER_VAR := 2147483647;

		-- implicit cast to number
		INSERT INTO PLS_INTEGER_TABLE(COL) VALUES (:PLS_INTEGER_VAR);
		PLS_INTEGER_VAR := 2147483647;

	-- operations with other numeric expressions
	INSERT INTO PLS_INTEGER_TABLE(COL) VALUES (:PLS_INTEGER_VAR + 1);
	INSERT INTO PLS_INTEGER_TABLE(COL) VALUES (:PLS_INTEGER_VAR + :NUMBER_VAR);
	END;
$$;

CALL PLS_INTEGER_EXAMPLE();

SELECT * FROM
	PLS_INTEGER_TABLE;
```

##### Result[¶](#id224)

<!-- prettier-ignore -->
|COL|
|---|
|2147483647|
|2147483648|
|2147483649|

### Known Issues[¶](#id225)

#### 1. Storage and performance features were not preserved[¶](#storage-and-performance-features-were-not-preserved)

Oracle `PLS_INTEGER` has some advantages in terms of storage size and performance in arithmetic
operations. These features were not emulated because Snowflake `NUMBER` does not have them. For more
information, check the
[PLS_INTEGER documentation.](https://docs.oracle.com/en/database/oracle/oracle-database/21/lnpls/plsql-data-types.html#GUID-9517B7AC-9CEA-4C36-A454-52588BEEBE8F)

### Related EWIs[¶](#id226)

No related EWIs.

## Character Data Types[¶](#character-data-types)

> Character data types store character (alphanumeric) data, which are words and free-form text, in
> the database character set or national character set.
> ([Oracle SQL Language Reference Character Data Types](https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/Data-Types.html#GUID-1BABC478-FB47-4962-9B0C-8B8BD059E733))

## CHAR Data type[¶](#char-data-type)

### Description[¶](#id227)

> The `CHAR` data type specifies a **fixed**-length character string in the database character
> set.([Oracle SQL Language Reference CHAR Data type](https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/Data-Types.html#GUID-85E0A0DD-9E90-4AE1-9AD5-93C89FDCFC49))

As denoted in the Oracle documentation, size in CHAR data type is a length constraint and should not
be confused with capacity. Total characters that can be stored in a CHAR may vary according to the
database character set and configuration, but commonly the maximum size allowed is 2000.

In Snowflake, CHAR types are synonymous with VARCHAR, and as you can check here:

[Snowflake SQL Language reference text data types](https://docs.snowflake.com/en/sql-reference/data-types-text.html#varchar)

The standard maximum size is quite bigger. But, this doesn’t mean that a Snowflake VARCHAR will
consume more storage, as mentioned in their documentation:

> A 1-character string in a VARCHAR(16777216) column only consumes a single character.

```
CHAR [ (size [ BYTE | CHAR ]) ]
```

### Sample Source Patterns[¶](#id228)

#### Char data types in Create Table[¶](#char-data-types-in-create-table)

##### Oracle[¶](#id229)

```
CREATE TABLE char_data_types
(
	char_column1 CHAR,
	char_column2 CHAR(15),
	char_column3 CHAR(15 BYTE),
	char_column4 CHAR(15 CHAR)
);

INSERT INTO char_data_types VALUES ('H', 'Hello world', 'Hello world', 'Hello world');
```

##### Snowflake[¶](#id230)

```
CREATE OR REPLACE TABLE char_data_types
(
	char_column1 CHAR,
	char_column2 CHAR(15),
	char_column3 CHAR(15),
	char_column4 CHAR(15)
)
COMMENT = '{"origin":"sf_sc","name":"snowconvert","version":{"major":1, "minor":0},{"attributes":{"component":"oracle"}}'
;

INSERT INTO char_data_types
VALUES ('H', 'Hello world', 'Hello world', 'Hello world');
```

#### Retrieving data from char columns[¶](#retrieving-data-from-char-columns)

##### Oracle[¶](#id231)

```
SELECT * FROM char_data_types;
```

##### Result[¶](#id232)

<!-- prettier-ignore -->
|CHAR_COLUMN1|CHAR_COLUMN2|CHAR_COLUMN3|CHAR_COLUMN4|
|---|---|---|---|
|H|Hello world|Hello world|Hello world|

##### Snowflake[¶](#id233)

```
SELECT * FROM
char_data_types;
```

##### Result[¶](#id234)

<!-- prettier-ignore -->
|CHAR_COLUMN1|CHAR_COLUMN2|CHAR_COLUMN3|CHAR_COLUMN4|
|---|---|---|---|
|H|Hello world|Hello world|Hello world|

**Note:**

In Oracle, the value is filled with empty spaces to fit the fixed size determined in the column
definition. On the other hand, Snowflakes uses dynamic size (keeping the length restriction) to
store the value.

#### Checking internal data types for CHAR[¶](#checking-internal-data-types-for-char)

As mentioned in the beginning, Snowflake internally uses a VARCHAR for the CHAR type columns, we can
confirm it by describing the tables:

##### Oracle[¶](#id235)

![](../../../../../../_images/image%28106%29%281%29.png)

##### Snowflake[¶](#id236)

![](../../../../../../_images/image%28198%29%281%29.png)

**Note:**

The length restriction is preserved, but the memory that the columns are using is different on each
DBMS.

#### Retrieving the size in bytes of each column:[¶](#retrieving-the-size-in-bytes-of-each-column)

##### Oracle[¶](#id237)

```
SELECT
LENGTHB(char_column1),
LENGTHB(char_column2),
LENGTHB(char_column3),
LENGTHB(char_column4)
FROM char_data_types;
```

##### Result[¶](#id238)

<!-- prettier-ignore -->
|LENGTHB(CHAR_COLUMN1)|LENGTHB(CHAR_COLUMN2)|LENGTHB(CHAR_COLUMN3)|LENGTHB(CHAR_COLUMN4)|
|---|---|---|---|
|1|15|15|15|

##### Snowflake[¶](#id239)

```
SELECT
OCTET_LENGTH(char_column1) /*** SSC-FDM-OR0015 - LENGTHB TRANSFORMED TO OCTET_LENGTH RESULTS MAY VARY DUE TO MEMORY MANAGEMENT OF DBMS ***/,
OCTET_LENGTH(char_column2) /*** SSC-FDM-OR0015 - LENGTHB TRANSFORMED TO OCTET_LENGTH RESULTS MAY VARY DUE TO MEMORY MANAGEMENT OF DBMS ***/,
OCTET_LENGTH(char_column3) /*** SSC-FDM-OR0015 - LENGTHB TRANSFORMED TO OCTET_LENGTH RESULTS MAY VARY DUE TO MEMORY MANAGEMENT OF DBMS ***/,
OCTET_LENGTH(char_column4) /*** SSC-FDM-OR0015 - LENGTHB TRANSFORMED TO OCTET_LENGTH RESULTS MAY VARY DUE TO MEMORY MANAGEMENT OF DBMS ***/
FROM
char_data_types;
```

##### Result[¶](#id240)

<!-- prettier-ignore -->
|OCTET_LENGTH(CHAR_COLUMN1)|OCTET_LENGTH(CHAR_COLUMN2)|OCTET_LENGTH(CHAR_COLUMN3)|OCTET_LENGTH(CHAR_COLUMN4)|
|---|---|---|---|
|1|11|11|11|

**Note:**

Besides these slight differences, the integrity of the data is preserved.

### Known Issues[¶](#id241)

**1. Results obtained from some built-in functions may vary**

As explained in the previous section, there may be cases using built-in functions over the columns
that may retrieve different results. For example, get the length of a column.

### Related EWIs[¶](#id242)

1. [SSC-FDM-OR0015](../../../../general/technical-documentation/issues-and-troubleshooting/functional-difference/oracleFDM.html#ssc-fdm-or0015):
   LENGTHB transformed to OCTET_LENGTH.

## NCHAR Data Type[¶](#nchar-data-type)

### Description[¶](#id243)

> The NCHAR data type specifies a **fixed**-length character string in the national character set.
> ([Oracle SQL Language Reference NCHAR](https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/Data-Types.html#GUID-FE15E51B-52C6-45D7-9883-4DF47716A17D))

NCHAR allows to store special characters with their Unicode to be preserved across any usage, these
special characters may need more bits to be stored and that is why, by default, the NCHAR character
set is `AL16UTF16`, contrary to the common character data set for CHAR which is usually `AL32UTF8`.

NCHAR is preserved as NCHAR in Snowflake, but, in the background, Snowflake uses VARCHAR.
[Transformation information related to CHAR](#char-data-type) is also valid for NCHAR.

```
NCHAR [ (size) ]
```

### Sample Souce Patterns[¶](#sample-souce-patterns)

#### Nchar data types in Create Table[¶](#nchar-data-types-in-create-table)

##### Oracle[¶](#id244)

```
CREATE TABLE nchar_data_types
(
	nchar_column1 NCHAR,
	nchar_column2 NCHAR(5)
);

INSERT INTO nchar_data_types VALUES ('ភ', 'ភាសាខ');
```

##### Snowflake[¶](#id245)

```
CREATE OR REPLACE TABLE nchar_data_types
(
	nchar_column1 NCHAR,
	nchar_column2 NCHAR(5)
)
COMMENT = '{"origin":"sf_sc","name":"snowconvert","version":{"major":1, "minor":0},{"attributes":{"component":"oracle"}}'
;

INSERT INTO nchar_data_types
VALUES ('ភ', 'ភាសាខ');
```

**Note:**

In Oracle, trying to insert these values in a CHAR column with the same size, will trigger an error:
_value too large for column_.

#### Retrieving information from Nchar columns[¶](#retrieving-information-from-nchar-columns)

##### Oracle[¶](#id246)

```
SELECT * FROM nchar_data_types;
```

##### Result[¶](#id247)

<!-- prettier-ignore -->
|NCHAR_COLUMN1|NCHAR_COLUMN2|
|---|---|
|ភ|ភាសាខ|

##### Snowflake[¶](#id248)

```
SELECT * FROM
nchar_data_types;
```

##### Result[¶](#id249)

<!-- prettier-ignore -->
|NCHAR_COLUMN1|NCHAR_COLUMN2|
|---|---|
|ភ|ភាសាខ|

#### Retrieving the size in bytes of each column[¶](#id250)

##### Oracle[¶](#id251)

```
SELECT
LENGTHB(nchar_column1),
LENGTHB(nchar_column2)
FROM nchar_data_types;
```

##### Result[¶](#id252)

<!-- prettier-ignore -->
|LENGTHB(NCHAR_COLUMN1)|LENGTHB(NCHAR_COLUMN2)|
|---|---|

```
                 2|                    10|
```

##### Snowflake[¶](#id253)

```
SELECT
OCTET_LENGTH(nchar_column1) /*** SSC-FDM-OR0015 - LENGTHB TRANSFORMED TO OCTET_LENGTH RESULTS MAY VARY DUE TO MEMORY MANAGEMENT OF DBMS ***/,
OCTET_LENGTH(nchar_column2) /*** SSC-FDM-OR0015 - LENGTHB TRANSFORMED TO OCTET_LENGTH RESULTS MAY VARY DUE TO MEMORY MANAGEMENT OF DBMS ***/
FROM
nchar_data_types;
```

##### Result[¶](#id254)

<!-- prettier-ignore -->
|OCTET_LENGTH(NCHAR_COLUMN1)|OCTET_LENGTH(NCHAR_COLUMN2)|
|---|---|

```
                      3|                         15|
```

Note that the number specified in the column declaration is the size in characters and not in bytes,
That is why we see more space used to store those special characters.

**Note:**

In Snowflake, VARCHAR uses UTF-8, size can vary depending on the Unicode character that can be
represented in 1, 2, 3, or 4 bytes. In this case, the Cambodian character is using 3 bytes to be
stored.

**Note:**

Besides these slight differences, the integrity of the data is preserved.

### Known Issues[¶](#id255)

**1. Results obtained from some built-in functions may vary**

As explained in the previous section, there may be cases using built-in functions over the columns
that may retrieve different results. For example, get the length of a column.

### Related EWIs[¶](#id256)

1. [SSC-FDM-OR0015](../../../../general/technical-documentation/issues-and-troubleshooting/functional-difference/oracleFDM.html#ssc-fdm-or0015):
   LENGTHB transformed to OCTET_LENGTH.

## NVARCHAR2 Data Type[¶](#nvarchar2-data-type)

### Description[¶](#id257)

> The `NVARCHAR2` data type specifies a variable-length character string in the national character
> set.
> ([Oracle SQL Language Reference NVARCHAR2](https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/Data-Types.html#GUID-DF7E10FC-A461-4325-A295-3FD4D150809E))

```
NVARCHAR2 (size)
```

NVARCHAR2 allows to store special characters with their Unicode to be preserved across any usage,
these special characters may need more bits to be stored and that is why, by default, the NVARCHAR2
character set is `AL16UTF16`, contrary to the common character data set for VARCHAR2 which is
usually `AL32UTF8`.

NVARCHAR transformed to Snowflake VARCHAR,
[Transformation information related to VARCHAR2](#varchar2-data-type), is also valid for NVARCHAR2.

```
NVARCHAR2 (size)
```

### Sample Souce Patterns[¶](#id258)

#### Nvarchar2 data type in Create Table[¶](#nvarchar2-data-type-in-create-table)

##### Oracle[¶](#id259)

```
CREATE TABLE nvarchar2_data_types
(
	nvarchar2_column NVARCHAR2 (5)
);

INSERT INTO nvarchar2_data_types VALUES ('ភាសាខ');
```

##### Snowflake[¶](#id260)

```
CREATE OR REPLACE TABLE nvarchar2_data_types
	(
		nvarchar2_column VARCHAR(5)
	)
	COMMENT = '{"origin":"sf_sc","name":"snowconvert","version":{"major":1, "minor":0},{"attributes":{"component":"oracle"}}'
	;

	INSERT INTO nvarchar2_data_types
	VALUES ('ភាសាខ');
```

**Note:**

In Oracle, trying to insert these values in a VARCHAR2 column with the same size, will trigger an
error: _value too large for column_.

#### Retrieving information from Nchar columns[¶](#id261)

##### Oracle[¶](#id262)

```
SELECT * FROM nvarchar2_data_types;
```

##### Result[¶](#id263)

<!-- prettier-ignore -->
|NVARCHAR2_COLUMN|
|---|
|ភាសាខ|

##### Snowflake[¶](#id264)

```
SELECT * FROM
nvarchar2_data_types;
```

##### Result[¶](#id265)

<!-- prettier-ignore -->
|NVARCHAR2_COLUMN|
|---|
|ភាសាខ|

#### Retrieving the size in bytes of each column[¶](#id266)

##### Oracle[¶](#id267)

```
SELECT
LENGTHB(nvarchar2_column)
FROM nvarchar2_data_types;
```

##### Result[¶](#id268)

<!-- prettier-ignore -->
|LENGTHB(NVARCHAR2_COLUMN)|
|---|
|10|

##### Snowflake[¶](#id269)

```
SELECT
OCTET_LENGTH(nvarchar2_column) /*** SSC-FDM-OR0015 - LENGTHB TRANSFORMED TO OCTET_LENGTH RESULTS MAY VARY DUE TO MEMORY MANAGEMENT OF DBMS ***/
FROM
nvarchar2_data_types;
```

##### Result[¶](#id270)

<!-- prettier-ignore -->
|OCTET_LENGTH(NVARCHAR2_COLUMN)|
|---|
|15|

Note that the number specified in the column declaration is the size in characters and not in bytes,
That is why we see more space used to store those special characters.

**Note:**

In Snowflake, VARCHAR uses UTF-8, size can vary depending on the Unicode character that can be
represented in 1, 2, 3, or 4 bytes. In this case, the Cambodian characters are using 3 bytes to be
stored.

**Note:**

Besides these slight differences, the integrity of the data is preserved.

### Known Issues[¶](#id271)

**1. Results obtained from some built-in functions may vary**

As explained in the previous section, there may be cases using built-in functions over the columns
that may retrieve different results. For example, get the length of a column.

### Related EWIs[¶](#id272)

1. [SSC-FDM-OR0015](../../../../general/technical-documentation/issues-and-troubleshooting/functional-difference/oracleFDM.html#ssc-fdm-or0015):
   LENGTHB transformed to OCTET_LENGTH.

## VARCHAR Data Type[¶](#varchar-data-type)

### Description[¶](#id273)

Oracle recommends using VARCHAR2 instead of VARCHAR as explained in their documentation:

[Oracle SQL Language reference Varchar](https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/Data-Types.html#GUID-DF7E10FC-A461-4325-A295-3FD4D150809E)

Even though, the syntaxis is parsed and transformed using the
[ANSI, DB2, and SQL/DS Data Types.](README.html#ansi-data-types)

## VARCHAR2 Data Type[¶](#varchar2-data-type)

### Description[¶](#id274)

> The `VARCHAR2` data type specifies a **variable**-length character string in the database
> character set.
> ([Oracle SQL Language Reference VARCHAR2](https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/Data-Types.html#GUID-0DC7FFAA-F03F-4448-8487-F2592496A510))

As denoted in the Oracle documentation, size in VARCHAR2 data type is a length constraint and should
not be confused with capacity. Total characters that can be stored in a VARCHAR2 may vary according
to the database character set and configuration, but commonly the maximum size allowed is 4000.

VARCHAR2 is translated to Snowflake VARCHAR which can store a bigger number of bytes/characters by
default. Either way, the memory used is variable using the size of the value stored in the column as
same as in Oracle.

```
VARCHAR2 (size [ BYTE | CHAR ])
```

### Sample Source Patterns[¶](#id275)

#### Varchar2 data types in Create Table[¶](#varchar2-data-types-in-create-table)

##### Oracle[¶](#id276)

```
CREATE TABLE varchar2_data_types
(
	varchar2_column1 VARCHAR2(5),
	varchar2_column2 VARCHAR2(5 BYTE),
	varchar2_column3 VARCHAR2(5 CHAR)
);

INSERT INTO varchar2_data_types VALUES ('H', 'Hello', 'Hell');
```

##### Snowflake[¶](#id277)

```
CREATE OR REPLACE TABLE varchar2_data_types
	(
		varchar2_column1 VARCHAR(5),
		varchar2_column2 VARCHAR(5),
		varchar2_column3 VARCHAR(5)
	)
	COMMENT = '{"origin":"sf_sc","name":"snowconvert","version":{"major":1, "minor":0},{"attributes":{"component":"oracle"}}'
	;

	INSERT INTO varchar2_data_types
	VALUES ('H', 'Hello', 'Hell');
```

#### Retrieving data from varchar columns[¶](#retrieving-data-from-varchar-columns)

##### Oracle[¶](#id278)

```
SELECT * FROM varchar2_data_types;
```

###### Result[¶](#id279)

<!-- prettier-ignore -->
|VARCHAR2_COLUMN1|VARCHAR2_COLUMN2|VARCHAR2_COLUMN3|
|---|---|---|
|H|Hello|Hell|

##### Snowflake[¶](#id280)

```
SELECT * FROM
varchar2_data_types;
```

###### Result[¶](#id281)

<!-- prettier-ignore -->
|VARCHAR2_COLUMN1|VARCHAR2_COLUMN2|VARCHAR2_COLUMN3|
|---|---|---|
|H|Hello|Hell|

#### Reviewing the variable size in the columns[¶](#reviewing-the-variable-size-in-the-columns)

##### Oracle[¶](#id282)

```
SELECT
LENGTHB(varchar2_column1),
LENGTHB(varchar2_column2),
LENGTHB(varchar2_column3)
FROM VARCHAR2_DATA_TYPES;
```

###### Result[¶](#id283)

<!-- prettier-ignore -->
|LENGTHB(VARCHAR2_COLUMN1)|LENGTHB(VARCHAR2_COLUMN2)|LENGTHB(VARCHAR2_COLUMN3)|
|---|---|---|
|1|5|4|

##### Snowflake[¶](#id284)

```
SELECT
OCTET_LENGTH(varchar2_column1) /*** SSC-FDM-OR0015 - LENGTHB TRANSFORMED TO OCTET_LENGTH RESULTS MAY VARY DUE TO MEMORY MANAGEMENT OF DBMS ***/,
OCTET_LENGTH(varchar2_column2) /*** SSC-FDM-OR0015 - LENGTHB TRANSFORMED TO OCTET_LENGTH RESULTS MAY VARY DUE TO MEMORY MANAGEMENT OF DBMS ***/,
OCTET_LENGTH(varchar2_column3) /*** SSC-FDM-OR0015 - LENGTHB TRANSFORMED TO OCTET_LENGTH RESULTS MAY VARY DUE TO MEMORY MANAGEMENT OF DBMS ***/
FROM
VARCHAR2_DATA_TYPES;
```

###### Result[¶](#id285)

<!-- prettier-ignore -->
|OCTET_LENGTH(VARCHAR2_COLUMN1)|OCTET_LENGTH(VARCHAR2_COLUMN2)|OCTET_LENGTH(VARCHAR2_COLUMN3)|
|---|---|---|
|1|5|4|

### Known Issues[¶](#id286)

No issues were found.

### Related EWIs[¶](#id287)

1. [SSC-FDM-OR0015](../../../../general/technical-documentation/issues-and-troubleshooting/functional-difference/oracleFDM.html#ssc-fdm-or0015):
   LENGTHB transformed to OCTET_LENGTH.

## LOB Data Types[¶](#lob-data-types)

### Description[¶](#id288)

> The built-in LOB data types `BLOB`, `CLOB`, and `NCLOB` (stored internally) and `BFILE` (stored
> externally) can store large and unstructured data such as text, image, video, and spatial data.
> ([Oracle SQL Language Reference LOB Data Type](https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/Data-Types.html#GUID-1A71C635-188E-4EC9-B821-1DBEC2B45451))

```
BFILE
BLOB
CLOB
NCLOB
```

Warning

LOB data types are **not supported** in Snowflake. Per
[Snowflake’s documentation](https://docs.snowflake.com/en/sql-reference/data-types-unsupported.html),
it is recommended to transform `CLOB` to `VARCHAR`, and `BLOB` to `BINARY`, however, there are
several limitations. {% endhint %}

Warning

LOB properties for tables are also **not supported** in Snowflake. {% endhint %}

## BFILE Data Type

### Description

> Contains a locator to a large binary file stored outside the database. Enables byte stream I/O
> access to external LOBs residing on the database server. A `BFILE` column or attribute stores a
> `BFILE` locator, which serves as a pointer to a binary file on the server file system. The locator
> maintains the directory name and the filename.
> ([Oracle SQL Language Reference BFILE Data Type](https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/Data-Types.html#GUID-3D9CC018-1637-45CB-95CF-DE67319D1A54)).

Warning

BFILE Data Type is **not supported** in Snowflake. VARCHAR is used instead.

### Sample Source Patterns[¶](#id290)

#### Bfile data type in Create Table[¶](#bfile-data-type-in-create-table)

Warning

Oracle `BFILE` columns are used to store a locator with the directory and filename. They are changed
to Snowflake `VARCHAR` in order to store the directory and filename into the column. However,
loading the content of the file must be done manually.

##### Oracle[¶](#id291)

```
--Create Table
CREATE TABLE bfile_table
(
    col1 BFILE
);

--Insert Bfilename
INSERT INTO bfile_table VALUES (
    BFILENAME('mydirectory', 'myfile.png')
);

--Select
SELECT * FROM bfile_table;
```

##### Result[¶](#id292)

<!-- prettier-ignore -->
|COL1|
|---|
|[BFILE:myfile.png]|

##### Snowflake[¶](#id293)

```
--Create Table
CREATE OR REPLACE TABLE bfile_table
    (
        col1
    !!!RESOLVE EWI!!! /*** SSC-EWI-OR0105 - ADDITIONAL WORK IS NEEDED FOR BFILE COLUMN USAGE. BUILD_STAGE_FILE_URL FUNCTION IS A RECOMMENDED WORKAROUND ***/!!!
    VARCHAR
    )
COMMENT = '{"origin":"sf_sc","name":"snowconvert","version":{"major":1, "minor":0},{"attributes":{"component":"oracle"}}'
;

--Insert Bfilename
INSERT INTO bfile_table
VALUES (PUBLIC.BFILENAME_UDF('mydirectory', 'myfile.png')
);

--Select
SELECT * FROM
    bfile_table;
```

##### Result[¶](#id294)

<!-- prettier-ignore -->
|COL1|
|---|
|mydirectory\myfile.png|

Warning

UDF added to replace `BFILENAME()`.

**UDF Added**

```
CREATE OR REPLACE FUNCTION PUBLIC.BFILENAME_UDF (DIRECTORYNAME STRING, FILENAME STRING)
RETURNS STRING
LANGUAGE SQL
IMMUTABLE
COMMENT = '{"origin":"sf_sc","name":"snowconvert","version":{"major":1, "minor":0},"attributes":{"component":"udf"}}'
AS
$$
	DIRECTORYNAME || '\\' || FILENAME
$$;
```

### Known Issues[¶](#id295)

#### 1. No access to the DBMS_LOB built-in package[¶](#no-access-to-the-dbms-lob-built-in-package)

Since LOB data types are not supported in Snowflake there is no equivalent for the `DBMS_LOB`
functions and there are no implemented workarounds yet.

### Related EWIs[¶](#id296)

1. [SSC-EWI-OR0105](../../../../general/technical-documentation/issues-and-troubleshooting/conversion-issues/oracleEWI.html#ssc-ewi-or0105):
   Additional work is needed for BFILE column usage. BUILD_STAGE_URL function is a recommended
   workaround.

## BLOB Data Type[¶](#blob-data-type)

### Description[¶](#id297)

> The `BLOB` data type stores unstructured binary large objects. `BLOB` objects can be thought of as
> bitstreams with no character set semantics.
> ([Oracle SQL Language Reference BLOB Data Type](https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/Data-Types.html#GUID-4570CDFD-8F91-44B9-BE7F-13076AA2AEBF)).

Warning

BLOB Data Type is **not supported** in Snowflake. BINARY is used instead.

### Sample Source Patterns[¶](#id298)

#### BLOB in Create Table[¶](#blob-in-create-table)

##### Oracle[¶](#id299)

```
CREATE TABLE blobtable( blob_column BLOB, empty_column BLOB );

INSERT INTO blobtable VALUES (NULL, EMPTY_BLOB());
```

##### Snowflake[¶](#id300)

```
CREATE OR REPLACE TABLE blobtable ( blob_column BINARY,
empty_column BINARY
)
COMMENT = '{"origin":"sf_sc","name":"snowconvert","version":{"major":1, "minor":0},{"attributes":{"component":"oracle"}}'
;

INSERT INTO blobtable
VALUES (NULL, TO_BINARY(' '));
```

#### Retrieving Data[¶](#retrieving-data)

##### Oracle[¶](#id301)

```
SELECT * FROM blobtable;
```

##### Result[¶](#id302)

<!-- prettier-ignore -->
|BLOB_COLUMN|EMPTY_COLUMN|
|---|---|
|[NULL]|[BLOB]|

##### Snowflake[¶](#id303)

```
SELECT * FROM
blobtable;
```

##### Result[¶](#id304)

<!-- prettier-ignore -->
|BLOB_COLUMN|EMPTY_COLUMN|
|---|---|
|NULL||

#### Functional Example[¶](#functional-example)

Warning

This example **is not a translation** of SnowConvert AI, it is only used to show the functional
equivalence between Oracle `BLOB` and Snowflake `BINARY`

Warning

We are using “`utl_raw.cast_to_raw`” and “`DBMS_LOB.SUBSTR`” functions. The conversion for these
functions is currently **not supported** by SnowConvert.

##### Oracle[¶](#id305)

```
INSERT INTO blobtable VALUES(
utl_raw.cast_to_raw('hello world'), EMPTY_BLOB());

SELECT DBMS_LOB.SUBSTR(blob_column) AS result
FROM blobtable;
```

##### Result[¶](#id306)

<!-- prettier-ignore -->
|RESULT|
|---|
|[NULL]|
|hello world|

##### Snowflake[¶](#id307)

```
INSERT INTO blobtable
VALUES(
!!!RESOLVE EWI!!! /*** SSC-EWI-OR0076 - TRANSLATION FOR BUILT-IN PACKAGE 'utl_raw.cast_to_raw' IS NOT CURRENTLY SUPPORTED. ***/!!!
'' AS cast_to_raw, TO_BINARY(' '));


SELECT
SUBSTR(blob_column, 1) AS result
FROM
blobtable;
```

##### Result[¶](#id308)

<!-- prettier-ignore -->
|RESULT|
|---|
|[NULL]|
|hello world|

### Known Issues[¶](#id309)

#### 1. The difference in max length BLOB (Oracle) and BINARY (Snowflake)[¶](#the-difference-in-max-length-blob-oracle-and-binary-snowflake)

An
[Oracle BLOB](https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/Data-Types.html#GUID-4570CDFD-8F91-44B9-BE7F-13076AA2AEBF)
column’s maximum size is **(4 gigabytes - 1) \* (database block size)**, but
[Snowflake BINARY](https://docs.snowflake.com/en/sql-reference/data-types-text.html#binary) is
limited to **8MB**.

##### 2. Empty value with EMPTY_BLOB[¶](#empty-value-with-empty-blob)

Initializing a column using `EMPTY_BLOB()` will return an empty LOB locator. While after translation
the column will return a string with ‘ ‘.

##### 3. No access to the DBMS_LOB built-in package[¶](#id310)

Since LOB data types are not supported in Snowflake there is no equivalent for the `DBMS_LOB`
functions and there are no implemented workarounds yet.

### Related EWIs[¶](#id311)

1. [SSC-EWI-OR0076](../../../../general/technical-documentation/issues-and-troubleshooting/conversion-issues/oracleEWI.html#ssc-ewi-or0076):
   Built In Package Not Supported.

## CLOB Data Type[¶](#clob-data-type)

### Description[¶](#id312)

> A character large object containing single-byte or multibyte characters. Both fixed-width and
> variable-width character sets are supported, both using the database character set.
> ([Oracle SQL Language Reference CLOB Data Type](https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/Data-Types.html#GUID-0EAC5929-0674-429C-AF42-2D454C982F8F)).

Warning

CLOB Data Type is **not supported** in Snowflake. VARCHAR is used instead.

### Sample Source Patterns[¶](#id313)

#### CLOB in Create Table[¶](#clob-in-create-table)

##### Oracle[¶](#id314)

```
CREATE TABLE clobtable ( clob_column CLOB, empty_column CLOB );

INSERT INTO clobtable VALUES ( 'THIS IS A TEST', EMPTY_CLOB() );
```

##### Snowflake[¶](#id315)

```
CREATE OR REPLACE TABLE clobtable ( clob_column VARCHAR,
empty_column VARCHAR
)
COMMENT = '{"origin":"sf_sc","name":"snowconvert","version":{"major":1, "minor":0},{"attributes":{"component":"oracle"}}'
;

INSERT INTO clobtable
VALUES ( 'THIS IS A TEST', TO_VARCHAR(' - '));
```

#### Retrieving Data[¶](#id316)

##### Oracle[¶](#id317)

```
SELECT * FROM clobtable;
```

##### Result[¶](#id318)

<!-- prettier-ignore -->
|CLOB_COLUMN|EMPTY_COLUMN|
|---|---|
|THIS IS A TEST||

##### Snowflake[¶](#id319)

```
SELECT * FROM
clobtable;
```

##### Result[¶](#id320)

<!-- prettier-ignore -->
|CLOB_COLUMN|EMPTY_COLUMN|
|---|---|
|THIS IS A TEST|-|

### Known Issues[¶](#id321)

#### 1. The difference in max length CLOB (Oracle) and VARCHAR (Snowflake)[¶](#the-difference-in-max-length-clob-oracle-and-varchar-snowflake)

An
[Oracle CLOB](https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/Data-Types.html#GUID-0EAC5929-0674-429C-AF42-2D454C982F8F)
column maximum size is **(4 gigabytes - 1) \* (database block size)**, but
[Snowflake VARCHAR](https://docs.snowflake.com/en/sql-reference/data-types-text.html#varchar) is
limited to **16MB**.

##### 2. Empty value with EMPTY_CLOB[¶](#empty-value-with-empty-clob)

Initializing a column using `EMPTY_CLOB()` will return an empty LOB locator. While in Snowflake
after translation the column will return a string with ‘ `-` ‘.

##### 3. No access to the DBMS_LOB built-in package[¶](#id322)

Since LOB data types are not supported in Snowflake there is not an equivalent for the `DBMS_LOB`
functions and there are no implemented workarounds yet.

### Related EWIs[¶](#id323)

No related EWIs.

## NCLOB Data type[¶](#nclob-data-type)

### Description[¶](#id324)

> A character large object containing Unicode characters. Both fixed-width and variable-width
> character sets are supported, both using the database national character set.
> ([Oracle SQL Language Reference NCLOB Data Type](https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/Data-Types.html#GUID-AB053D2C-2A40-478E-82E5-B9176C8776FD)).

Warning

NCLOB Data Type is **not supported** in Snowflake. VARCHAR is used instead.

### Sample Source Patterns[¶](#id325)

#### NCLOB in Create Table[¶](#nclob-in-create-table)

##### Oracle[¶](#id326)

```
CREATE TABLE nclobtable ( nclob_column NCLOB, empty_column NCLOB );

INSERT INTO nclobtable VALUES ( 'THIS IS A TEST', EMPTY_CLOB() );
```

##### Snowflake[¶](#id327)

```
CREATE OR REPLACE TABLE nclobtable ( nclob_column VARCHAR,
empty_column VARCHAR
)
COMMENT = '{"origin":"sf_sc","name":"snowconvert","version":{"major":1, "minor":0},{"attributes":{"component":"oracle"}}'
;

INSERT INTO nclobtable
VALUES ( 'THIS IS A TEST', TO_VARCHAR(' - '));
```

#### Retrieving Data[¶](#id328)

##### Oracle[¶](#id329)

```
SELECT * FROM nclobtable;
```

##### Result[¶](#id330)

<!-- prettier-ignore -->
|NCLOB_COLUMN|EMPTY_COLUMN|
|---|---|
|THIS IS A TEST||

##### Snowflake[¶](#id331)

```
SELECT * FROM
nclobtable;
```

##### Result[¶](#id332)

<!-- prettier-ignore -->
|NCLOB_COLUMN|EMPTY_COLUMN|
|---|---|
|THIS IS A TEST|-|

### Known Issues[¶](#id333)

#### 1. The difference in max length CLOB (Oracle) and VARCHAR (Snowflake)[¶](#id334)

An
[Oracle NCLOB](https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/Data-Types.html#GUID-AB053D2C-2A40-478E-82E5-B9176C8776FD)
column maximum size is **(4 gigabytes - 1) \* (database block size)**, but
[Snowflake VARCHAR](https://docs.snowflake.com/en/sql-reference/data-types-text.html#varchar) is
limited to **16MB**.

##### 2. Empty value with EMPTY_CLOB[¶](#id335)

Initializing a column using `EMPTY_CLOB()` will return an empty LOB locator. While after translation
the column will return a string with ‘ `-` ‘.

##### 3. No access to the DBMS_LOB built-in package[¶](#id336)

Since LOB data types are not supported in Snowflake there is not an equivalent for the `DBMS_LOB`
functions and there are no implemented workarounds yet.

### Related EWIs[¶](#id337)

No related EWIs.
